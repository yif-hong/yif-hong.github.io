<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yif</title>
  
  <subtitle>学习使我快乐！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yif-hong.github.io/"/>
  <updated>2020-10-13T13:54:24.021Z</updated>
  <id>http://yif-hong.github.io/</id>
  
  <author>
    <name>Yif Hong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指 Offer 57 - II. 和为 s 的连续正数序列</title>
    <link href="http://yif-hong.github.io/2020/10/12/LC-offer-57/"/>
    <id>http://yif-hong.github.io/2020/10/12/LC-offer-57/</id>
    <published>2020-10-12T14:00:49.000Z</published>
    <updated>2020-10-13T13:54:24.021Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>“对于程序员而言，刷了Leetcode不一定能拿offer，但是不刷肯定拿不到offer。”</strong></p><footer><strong>Lusion</strong><cite>鲁迅</cite></footer></blockquote><a id="more"></a><p><img src="/2020/10/12/LC-offer-57/LeetcodeExercise/luxun.jpg" alt="Lusion"></p><h1 id="剑指-Offer-57-II-和为-s-的连续正数序列"><a href="#剑指-Offer-57-II-和为-s-的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为 s 的连续正数序列"></a>剑指 Offer 57 - II. 和为 s 的连续正数序列</h1><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p>示例 1：</p><p>输入：target = 9<br>输出：[[2,3,4],[4,5]]<br>示例 2：</p><p>输入：target = 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p><p>限制：</p><p>1 &lt;= target &lt;= 10^5</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="滑动窗口（双指针）"><a href="#滑动窗口（双指针）" class="headerlink" title="滑动窗口（双指针）"></a>滑动窗口（双指针）</h3><p>通过双指针，不断向右滑动：</p><p>$$<br>T(n) = O(n)<br>$$</p><p>$$<br>V(n) = O(1)<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = (start + end)*(end - start + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (sum &lt; target) end++;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) start++;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span>[] x = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x.length; i++) x[i] = start + i;</span><br><span class="line">        res.add(x);</span><br><span class="line">        start++;</span><br><span class="line">        end++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数学法"><a href="#数学法" class="headerlink" title="数学法"></a>数学法</h3><p>设子序列起始为a，长度为n，利用等差数列求和性质： <code>target = (a + (a + n-1))*n/2;</code> ，求得a与n的关系式，并通过遍历n，确定a的值。</p><ol><li>1&lt;= a &lt;= target/2</li><li>2&lt;= n &lt; target</li></ol><p>$$<br>T(n) = O(\sqrt n)<br>$$</p><p>$$<br>V(n) = O(1)<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">2</span>; n&lt;target; n++) &#123;</span><br><span class="line">      <span class="keyword">int</span> temp = target - (n-<span class="number">1</span>)*n/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (temp &lt; n) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (temp % n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = temp / n;</span><br><span class="line">        <span class="keyword">int</span>[] x = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) x[i] = i+a;</span><br><span class="line">        res.add(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(res);</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;“对于程序员而言，刷了Leetcode不一定能拿offer，但是不刷肯定拿不到offer。”&lt;/strong&gt;&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;Lusion&lt;/strong&gt;&lt;cite&gt;鲁迅&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yif-hong.github.io/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yif-hong.github.io/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yif-hong.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 29. 顺时针打印矩阵</title>
    <link href="http://yif-hong.github.io/2020/10/11/LC-offer-29/"/>
    <id>http://yif-hong.github.io/2020/10/11/LC-offer-29/</id>
    <published>2020-10-11T12:00:49.000Z</published>
    <updated>2020-10-13T13:52:42.927Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>“对于程序员而言，刷了Leetcode不一定能拿offer，但是不刷肯定拿不到offer。”</strong></p><footer><strong>Lusion</strong><cite>鲁迅</cite></footer></blockquote><a id="more"></a><p><img src="/2020/10/11/LC-offer-29/LeetcodeExercise/luxun.jpg" alt="Lusion"></p><h1 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a>剑指 Offer 29. 顺时针打印矩阵</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p>示例 1：</p><p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p><p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p><p>限制：</p><p>0 &lt;= matrix.length &lt;= 100<br>0 &lt;= matrix[i].length &lt;= 100<br>注意：本题与主站 54 题相同：<a href="https://leetcode-cn.com/problems/spiral-matrix/">https://leetcode-cn.com/problems/spiral-matrix/</a></p><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>将矩阵按层考虑，每次顺时针循环会遍历top、right、bottom、left，控制好边界即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>] == <span class="keyword">null</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].length - <span class="number">1</span>, top = <span class="number">0</span>, bottom = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[(right+<span class="number">1</span>)*(bottom+<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) res[x++] = matrix[top][i];</span><br><span class="line">      <span class="keyword">if</span> (++top &gt; bottom) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &lt;= bottom; i++) res[x++] = matrix[i][right];</span><br><span class="line">      <span class="keyword">if</span> (left &gt; --right) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt;= left; i--) res[x++] = matrix[bottom][i];</span><br><span class="line">      <span class="keyword">if</span> (top &gt; --bottom) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom; i &gt;= top; i--) res[x++] = matrix[i][left];</span><br><span class="line">      <span class="keyword">if</span> (++left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;“对于程序员而言，刷了Leetcode不一定能拿offer，但是不刷肯定拿不到offer。”&lt;/strong&gt;&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;Lusion&lt;/strong&gt;&lt;cite&gt;鲁迅&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yif-hong.github.io/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yif-hong.github.io/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yif-hong.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 21.  调整数组顺序使奇数位于偶数前面</title>
    <link href="http://yif-hong.github.io/2020/10/11/LC-offer-21/"/>
    <id>http://yif-hong.github.io/2020/10/11/LC-offer-21/</id>
    <published>2020-10-11T09:00:49.000Z</published>
    <updated>2020-10-11T09:38:34.510Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>“对于程序员而言，刷了Leetcode不一定能拿offer，但是不刷肯定拿不到offer。”</strong></p><footer><strong>Lusion</strong><cite>鲁迅</cite></footer></blockquote><a id="more"></a><p><img src="/2020/10/11/LC-offer-21/LeetcodeExercise/luxun.jpg" alt="Lusion"></p><h1 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p>示例：</p><p>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。</p><p>提示：</p><p>1 &lt;= nums.length &lt;= 50000<br>1 &lt;= nums[i] &lt;= 10000</p><hr><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><h3 id="首尾双指针"><a href="#首尾双指针" class="headerlink" title="首尾双指针"></a>首尾双指针</h3><h4 id="1-使用辅助数组：T-n-O-n-V-n-O-n"><a href="#1-使用辅助数组：T-n-O-n-V-n-O-n" class="headerlink" title="1. 使用辅助数组：T(n) = O(n), V(n) = O(n)"></a>1. 使用辅助数组：T(n) = O(n), V(n) = O(n)</h4><p>算法（略）</p><h5 id="优化：-采用位运算存储数据，T-n-O-n-V-n-O-1"><a href="#优化：-采用位运算存储数据，T-n-O-n-V-n-O-1" class="headerlink" title="优化： 采用位运算存储数据，T(n) = O(n), V(n) = O(1)"></a>优化： 采用位运算存储数据，T(n) = O(n), V(n) = O(1)</h5><p>观察到<code>1 &lt;= nums[i] &lt;= 10000 &lt; 2^14 = 16384</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((nums[i] &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        nums[right--] |= (nums[i]&amp;<span class="number">16383</span>)&lt;&lt;<span class="number">14</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nums[left++] |= (nums[i]&amp;<span class="number">16383</span>)&lt;&lt;<span class="number">14</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">      nums[i] &gt;&gt;= <span class="number">14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-采用快排思想：T-n-O-n-V-n-O-1"><a href="#2-采用快排思想：T-n-O-n-V-n-O-1" class="headerlink" title="2. 采用快排思想：T(n) = O(n), V(n) = O(1)"></a>2. 采用快排思想：T(n) = O(n), V(n) = O(1)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; j &amp;&amp; (nums[i]&amp;<span class="number">1</span>) == <span class="number">1</span>) i++;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; j &amp;&amp; (nums[j]&amp;<span class="number">1</span>) == <span class="number">0</span>) j--;</span><br><span class="line">      <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">      nums[i++] = nums[j];</span><br><span class="line">      nums[j--] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢双指针"><a href="#快慢双指针" class="headerlink" title="快慢双指针"></a>快慢双指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; j&lt;nums.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>((nums[j]&amp;<span class="number">1</span>)==<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">        nums[j] = nums[i];</span><br><span class="line">        nums[i++] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;“对于程序员而言，刷了Leetcode不一定能拿offer，但是不刷肯定拿不到offer。”&lt;/strong&gt;&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;Lusion&lt;/strong&gt;&lt;cite&gt;鲁迅&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yif-hong.github.io/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yif-hong.github.io/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yif-hong.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 17. 打印从 1 到最大的 n 位数</title>
    <link href="http://yif-hong.github.io/2020/10/11/LC-offer-17/"/>
    <id>http://yif-hong.github.io/2020/10/11/LC-offer-17/</id>
    <published>2020-10-11T02:00:49.000Z</published>
    <updated>2020-10-11T01:03:22.240Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>“对于程序员而言，刷了Leetcode不一定能拿offer，但是不刷肯定拿不到offer。”</strong></p><footer><strong>Lusion</strong><cite>鲁迅</cite></footer></blockquote><a id="more"></a><p><img src="/2020/10/11/LC-offer-17/LeetcodeExercise/luxun.jpg" alt="Lusion"></p><h1 id="剑指-Offer-17-打印从-1-到最大的-n-位数"><a href="#剑指-Offer-17-打印从-1-到最大的-n-位数" class="headerlink" title="剑指 Offer 17. 打印从 1 到最大的 n 位数"></a>剑指 Offer 17. 打印从 1 到最大的 n 位数</h1><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p>示例 1:</p><p>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p><p>说明：</p><p>用返回一个整数列表来代替打印<br>n 为正整数</p><h2 id="大数问题"><a href="#大数问题" class="headerlink" title="大数问题"></a>大数问题</h2><p>简单来看，遍历计算即可获取答案，由于要求返回的是int[]，故不会出现溢出情况。</p><p><strong>如果要求返回的是String，则是考察大数问题的处理。</strong><br>$$<br>T(n) = O(10^n)<br>$$</p><p>$$<br>V(n) = O(10^n)<br>$$</p><h3 id="String处理进位"><a href="#String处理进位" class="headerlink" title="String处理进位"></a>String处理进位</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">  <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, n) - <span class="number">1</span>];</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      str.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!increment(str)) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (index &lt; str.length() &amp;&amp; str.charAt(index) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        index++;</span><br><span class="line">      &#125;</span><br><span class="line">      res[count++] = Integer.parseInt(str.toString().substring(index));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">increment</span><span class="params">(StringBuilder str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isCarry = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">char</span> s = (<span class="keyword">char</span>)(str.charAt(i) + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (s &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        str.replace(i, i+<span class="number">1</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">          isCarry = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str.replace(i, i+<span class="number">1</span>, String.valueOf(s));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isCarry;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dfs全排列"><a href="#dfs全排列" class="headerlink" title="dfs全排列"></a>dfs全排列</h3><p>由于在09999这种情况下，会出现连续进位，遍历n-1次，需要从最低位到最高位循环判断，所以可以考虑<strong>全排列避开进位操作</strong>。（通过递归实现全排列，生成String列表）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] res;</span><br><span class="line">  <span class="keyword">int</span> nine = <span class="number">0</span>, count = <span class="number">0</span>, start, n;</span><br><span class="line">  <span class="keyword">char</span>[] num, loop = &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    res = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,n)-<span class="number">1</span>];</span><br><span class="line">    num = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">    start = n - <span class="number">1</span>;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == n) &#123;</span><br><span class="line">      String s = String.valueOf(num).substring(start);</span><br><span class="line">      <span class="keyword">if</span> (!s.equals(<span class="string">&quot;0&quot;</span>)) res[count++] = Integer.parseInt(s);</span><br><span class="line">      <span class="keyword">if</span> (n - start == nine) start--;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> i : loop) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="string">&#x27;9&#x27;</span>) nine++;</span><br><span class="line">      num[x] = i;</span><br><span class="line">      dfs(x+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nine--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;“对于程序员而言，刷了Leetcode不一定能拿offer，但是不刷肯定拿不到offer。”&lt;/strong&gt;&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;Lusion&lt;/strong&gt;&lt;cite&gt;鲁迅&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yif-hong.github.io/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yif-hong.github.io/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yif-hong.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Largest-Common-SubString Algorithm</title>
    <link href="http://yif-hong.github.io/2020/10/11/DP-LCS/"/>
    <id>http://yif-hong.github.io/2020/10/11/DP-LCS/</id>
    <published>2020-10-11T01:20:49.000Z</published>
    <updated>2020-10-11T01:03:24.650Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>“对于程序员而言，刷了Leetcode不一定能拿offer，但是不刷肯定拿不到offer。”</strong></p><footer><strong>Lusion</strong><cite>鲁迅</cite></footer></blockquote><a id="more"></a><p><img src="/2020/10/11/DP-LCS/LeetcodeExercise/luxun.jpg" alt="Lusion"></p><h3 id="Largest-Common-SubString-Algorithm"><a href="#Largest-Common-SubString-Algorithm" class="headerlink" title="Largest-Common-SubString Algorithm"></a>Largest-Common-SubString Algorithm</h3><p>$$<br>Time: \ T(n)=\Theta(m<em>n)<br>\<br>Space: \ V(n) = \Theta(m</em>n)<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">LCS(X,Y):</span><br><span class="line">m &#x3D; X.length - 1 </span><br><span class="line">n &#x3D; Y.length - 1</span><br><span class="line">let c[0...m][0...n], s[1..m][1..n] as new array</span><br><span class="line">for i &#x3D; 0 to n</span><br><span class="line">c[0][i] &#x3D; 0</span><br><span class="line">for i &#x3D; 1 to m</span><br><span class="line">c[i][0] &#x3D; 0</span><br><span class="line">for i &#x3D; 1 to m</span><br><span class="line">for j &#x3D; 1 to n</span><br><span class="line">if X[i] &#x3D;&#x3D; Y[j]</span><br><span class="line">c[i][j] &#x3D; c[i-1][j-1] + 1</span><br><span class="line">s[i][j] &#x3D; &quot;hit&quot;</span><br><span class="line">else</span><br><span class="line">if c[i][j] &lt;&#x3D; c[i-1][j]</span><br><span class="line">c[i][j] &#x3D; c[i-1][j]</span><br><span class="line">s[i][j] &#x3D; &quot;up&quot;</span><br><span class="line">else </span><br><span class="line">c[i][j] &#x3D; c[i][j-1]</span><br><span class="line">s[i][j] &#x3D; &quot;left&quot;</span><br><span class="line">return c &amp;&amp; s</span><br><span class="line"></span><br><span class="line">PRINT-LCS()</span><br><span class="line">  c,s &#x3D; LCS(X,Y)</span><br><span class="line">PRINT-LCS(s,X,X.length-1,Y.length-1)</span><br><span class="line"></span><br><span class="line">PRINT-LCS(s,X,m,n)</span><br><span class="line">if m &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 0</span><br><span class="line">return</span><br><span class="line">if s[m][n] &#x3D;&#x3D; &quot;hit&quot;</span><br><span class="line">print X[m][n]</span><br><span class="line">PRINT-LCS(s[m-1][n-1],X,m-1,n-1)</span><br><span class="line">else if s[m][n] &#x3D;&#x3D; &quot;up&quot;</span><br><span class="line">PRINT-LCS(s[m-1][n],X,m-1,n)</span><br><span class="line">else PRINT-LCS(s[m][n-1],X,m,n-1)</span><br></pre></td></tr></table></figure><h4 id="Space-optimize"><a href="#Space-optimize" class="headerlink" title="Space optimize"></a>Space optimize</h4><h5 id="2-D-Vector-Storage"><a href="#2-D-Vector-Storage" class="headerlink" title="2-D Vector Storage"></a>2-D Vector Storage</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c[i][j] comes from c[i-1][j-1], c[i-1][j], c[i][j-1]</span><br><span class="line">make c[2][n] to store c[i][j]</span><br></pre></td></tr></table></figure><p>$$<br>Time: \ T(n)=\Theta(m*n)<br>\<br>Space: \ V(n) = \Theta(2n)<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LCS(X,Y):</span><br><span class="line">m &#x3D; X.length - 1 </span><br><span class="line">n &#x3D; Y.length - 1</span><br><span class="line">let c[2][0...n], s[1..m][1..n] as new array</span><br><span class="line">for i &#x3D; 0 to n</span><br><span class="line">c[0][i] &#x3D; 0</span><br><span class="line">for i &#x3D; 1 to 2</span><br><span class="line">c[i][0] &#x3D; 0</span><br><span class="line">for i &#x3D; 1 to m</span><br><span class="line">for j &#x3D; 1 to n</span><br><span class="line">if X[i] &#x3D;&#x3D; Y[j]</span><br><span class="line">c[i%2][j] &#x3D; c[(i-1)%2][j-1] + 1</span><br><span class="line">s[i][j] &#x3D; &quot;hit&quot;</span><br><span class="line">else</span><br><span class="line">if c[i%2][j] &lt;&#x3D; c[(i-1)%2][j]</span><br><span class="line">c[i%2][j] &#x3D; c[(i-1)%2][j]</span><br><span class="line">s[i][j] &#x3D; &quot;up&quot;</span><br><span class="line">else </span><br><span class="line">c[i%2][j] &#x3D; c[i%2][j-1]</span><br><span class="line">s[i][j] &#x3D; &quot;left&quot;</span><br><span class="line">return c &amp;&amp; s</span><br></pre></td></tr></table></figure><h5 id="1-D-Vector-Storage"><a href="#1-D-Vector-Storage" class="headerlink" title="1-D Vector Storage"></a>1-D Vector Storage</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c[i][j] comes from c[i-1][j-1], c[i-1][j], c[i][j-1]</span><br><span class="line">make c[n] to store c[i][j]</span><br><span class="line"></span><br><span class="line">c[i][j] &#x3D; 0 , i&#x3D;&#x3D;0 || j&#x3D;&#x3D;0</span><br><span class="line">c[i][j] &#x3D; c[i-1][j-1], X[i] &#x3D;&#x3D; Y[j]</span><br><span class="line">c[i][j] &#x3D; max&#123; c[i-1][j], c[i][j-1] &#125;</span><br></pre></td></tr></table></figure><p>$$<br>Time: \ T(n)=\Theta(m*n)<br>\<br>Space: \ V(n) = \Theta(n)<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LCS(X,Y):</span><br><span class="line">m &#x3D; X.length - 1 </span><br><span class="line">n &#x3D; Y.length - 1</span><br><span class="line">let c[n], s[1..m][1..n] as new array</span><br><span class="line">for i &#x3D; 0 to n</span><br><span class="line">c[i] &#x3D; 0</span><br><span class="line">prev &#x3D; 0</span><br><span class="line">for i &#x3D; 1 to m</span><br><span class="line">for j &#x3D; 1 to n</span><br><span class="line">temp &#x3D; c[j]</span><br><span class="line">if X[i] &#x3D;&#x3D; Y[j]</span><br><span class="line">c[j] &#x3D; prev + 1</span><br><span class="line">s[i][j] &#x3D; &quot;hit&quot;</span><br><span class="line">else</span><br><span class="line">if c[j] &lt;&#x3D; c[j-1]</span><br><span class="line">c[j] &#x3D; c[j-1]</span><br><span class="line">s[i][j] &#x3D; &quot;up&quot;</span><br><span class="line">else</span><br><span class="line">s[i][j] &#x3D; &quot;left&quot;</span><br><span class="line">prev &#x3D; temp</span><br><span class="line">return c &amp;&amp; s</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;“对于程序员而言，刷了Leetcode不一定能拿offer，但是不刷肯定拿不到offer。”&lt;/strong&gt;&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;Lusion&lt;/strong&gt;&lt;cite&gt;鲁迅&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yif-hong.github.io/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yif-hong.github.io/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yif-hong.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>DFS-Review</title>
    <link href="http://yif-hong.github.io/2020/10/11/DFS-Review/"/>
    <id>http://yif-hong.github.io/2020/10/11/DFS-Review/</id>
    <published>2020-10-11T01:00:49.000Z</published>
    <updated>2020-10-11T01:02:43.751Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>“对于程序员而言，刷了Leetcode不一定能拿offer，但是不刷肯定拿不到offer。”</strong></p><footer><strong>Lusion</strong><cite>鲁迅</cite></footer></blockquote><a id="more"></a><p><img src="/2020/10/11/DFS-Review/LeetcodeExercise/luxun.jpg" alt="Lusion"></p><h1 id="DFS-Review"><a href="#DFS-Review" class="headerlink" title="DFS-Review"></a>DFS-Review</h1><p>$$<br>T(n)=\Theta(V+E)<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DFS(G)</span><br><span class="line">  for each vertex u in G.V</span><br><span class="line">    u.color &#x3D; WHITE</span><br><span class="line">    u.p &#x3D; NIL</span><br><span class="line">  time &#x3D; 0</span><br><span class="line">  for each vertex u in G.V</span><br><span class="line">  if u.color &#x3D;&#x3D; WHITHE</span><br><span class="line">  DFS-VISIT(G,u)</span><br><span class="line">  </span><br><span class="line">DFS-VISIT(G,u)</span><br><span class="line">time &#x3D; time + 1</span><br><span class="line">u.d &#x3D; time</span><br><span class="line">u.color &#x3D; GRAY</span><br><span class="line">for vertex v in G:Adj[u]</span><br><span class="line">if v.color &#x3D;&#x3D; WHITE</span><br><span class="line">v.p &#x3D; u</span><br><span class="line">DFS-VISIT(G,v)</span><br><span class="line">u.color &#x3D; BLACK</span><br><span class="line">time &#x3D; time + 1</span><br><span class="line">u.f &#x3D; time</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TOPOLOGICAL-SORT(G)</span><br><span class="line">DFS(G)</span><br><span class="line">list add each vertex v which is in G.V sorted by desc of v.f</span><br><span class="line">return list</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;“对于程序员而言，刷了Leetcode不一定能拿offer，但是不刷肯定拿不到offer。”&lt;/strong&gt;&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;Lusion&lt;/strong&gt;&lt;cite&gt;鲁迅&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yif-hong.github.io/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yif-hong.github.io/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yif-hong.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>RedBlackBST Review</title>
    <link href="http://yif-hong.github.io/2020/09/13/RedBlackBST-Review/"/>
    <id>http://yif-hong.github.io/2020/09/13/RedBlackBST-Review/</id>
    <published>2020-09-13T11:00:00.000Z</published>
    <updated>2020-09-13T11:18:45.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RedBlackBST-Review"><a href="#RedBlackBST-Review" class="headerlink" title="RedBlackBST Review"></a>RedBlackBST Review</h1><p>This is a review about RedBlackBST by CLRS#3 &amp; Algorithm#4.</p><a id="more"></a><h2 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h2><ul><li>Average function<br>$$<br>T(n) = \Theta(2\lg{n})<br>$$</li></ul><h2 id="lt-CLRS-3-gt"><a href="#lt-CLRS-3-gt" class="headerlink" title="&lt;CLRS#3&gt;"></a>&lt;CLRS#3&gt;</h2><p><strong>Not figure out yet…</strong></p><h2 id="lt-Algorithm-4-gt"><a href="#lt-Algorithm-4-gt" class="headerlink" title="&lt;Algorithm#4&gt;"></a>&lt;Algorithm#4&gt;</h2><h3 id="RedBlackBST"><a href="#RedBlackBST" class="headerlink" title="RedBlackBST"></a>RedBlackBST</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">size:<span class="number">1</span></span><br><span class="line">color:BLACK</span><br><span class="line">Node left,right</span><br><span class="line">  key</span><br><span class="line">  val</span><br><span class="line">    </span><br><span class="line">size(x):</span><br><span class="line"><span class="keyword">if</span> x == NIL</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> size(x.left) + size(x.right) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">isRed(x):</span><br><span class="line"><span class="keyword">if</span> x == NIL</span><br><span class="line">    <span class="keyword">return</span> False</span><br><span class="line">  <span class="keyword">return</span> x.color == RED</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">rotateLeft(x):</span><br><span class="line">y &#x3D; x.right</span><br><span class="line">x.right &#x3D; y.left</span><br><span class="line">y.left &#x3D; x</span><br><span class="line">y.color &#x3D; y.left.color</span><br><span class="line">y.left.color &#x3D; RED</span><br><span class="line">y.size &#x3D; x.size</span><br><span class="line">x.size &#x3D; 1 + size(x.left) + size(x.right)</span><br><span class="line">return y</span><br><span class="line"></span><br><span class="line">rotateRight(x):</span><br><span class="line">y &#x3D; x.left</span><br><span class="line">x.left &#x3D; y.right</span><br><span class="line">y.right &#x3D; x</span><br><span class="line">y.color &#x3D; y.right.color</span><br><span class="line">y.right.color &#x3D; RED</span><br><span class="line">y.size &#x3D; x.size</span><br><span class="line">x.size &#x3D; 1 + size(x.left) + size(x.right)</span><br><span class="line">return y</span><br><span class="line"></span><br><span class="line">flipColors(x):</span><br><span class="line">if x !&#x3D; NIL and x.left !&#x3D; NIL and x.right !&#x3D; NIL</span><br><span class="line">x.color &#x3D; !x.color</span><br><span class="line">x.left.color &#x3D; !x.left.color</span><br><span class="line">x.right.color &#x3D; !x.right.color</span><br><span class="line">return x</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">put(x,key,val):</span><br><span class="line">if x &#x3D;&#x3D; NIL</span><br><span class="line">return new Node(k,val,1,RED)</span><br><span class="line">if key &lt; x.key</span><br><span class="line">put(x.left,key,val)</span><br><span class="line">elif key &gt; x.key</span><br><span class="line">put(x.right,key,val)</span><br><span class="line">else x.val &#x3D; val</span><br><span class="line">x &#x3D; balance(x)</span><br><span class="line">return x</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">balance(x):</span><br><span class="line">if !x.left.isRed() and x.right.isRed()</span><br><span class="line">x &#x3D; rotateLeft(x)</span><br><span class="line">if x.left.isRed() and x.left.left.isRed()</span><br><span class="line">x &#x3D; rotateRight(x)</span><br><span class="line">if x.left.isRed() and x.right.isRed()</span><br><span class="line">x &#x3D; flipColor(x)</span><br><span class="line">x.size &#x3D; size(x.left) + size(x.right) + 1</span><br><span class="line">return x</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assume that x is red, x.left and x.left.left is black</span></span><br><span class="line"><span class="comment">// make x.left or sub-node of x.left color to red</span></span><br><span class="line">moveRedLeft(x):</span><br><span class="line">flipColor(x)</span><br><span class="line"><span class="keyword">if</span> x.right.left.isRed()</span><br><span class="line">x.right = rotateRight(x.right)</span><br><span class="line">    x = rotateLeft(x)</span><br><span class="line">  <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deleteMin(x):</span><br><span class="line">if x.left &#x3D;&#x3D; NIL</span><br><span class="line">return NIL</span><br><span class="line">if !x.left.isRed() and !x.left.left.isRed()</span><br><span class="line">x &#x3D; moveRedLeft(x)</span><br><span class="line">x.left &#x3D; deleteMin(x.left)</span><br><span class="line">x &#x3D; balance(x)</span><br><span class="line">return x</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assume that x is red, x.right and x.right.left is black</span></span><br><span class="line"><span class="comment">// make x.right or sub-node of x.right color to red</span></span><br><span class="line">moveRedRight(x):</span><br><span class="line">flipColor(x)</span><br><span class="line"><span class="keyword">if</span> !x.left.left.isRed</span><br><span class="line">x = rotateRight(x)</span><br><span class="line"><span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deleteMax(x):</span><br><span class="line">if x.left.isRed()</span><br><span class="line">x &#x3D; rotateRight(x)</span><br><span class="line">if x &#x3D;&#x3D; NIL</span><br><span class="line">return NIL</span><br><span class="line">if !x.right.isRed() and !x.right.left.isRed()</span><br><span class="line">x &#x3D; moveRedRight(x)</span><br><span class="line">x.right &#x3D; deleteMax(x.right)</span><br><span class="line">x &#x3D; balance(x)</span><br><span class="line">return x</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// turn to delete deleteMin or deleteMax</span></span><br><span class="line"><span class="keyword">delete</span>(x, key):</span><br><span class="line"><span class="keyword">if</span> key &lt; x.key</span><br><span class="line">    <span class="keyword">if</span> !x.left.isRed() <span class="keyword">and</span> !x.left.left.isRed()</span><br><span class="line">      x = moveLeftRed(x)</span><br><span class="line">     x.left = <span class="keyword">delete</span>(x.left,key)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> x.left.isRed()</span><br><span class="line">      x = rotateRight(x)</span><br><span class="line">    <span class="keyword">if</span> key == x.key <span class="keyword">and</span> x.right == NIL</span><br><span class="line">      <span class="keyword">return</span> NIL</span><br><span class="line">    <span class="keyword">if</span> !x.right.isRed() <span class="keyword">and</span> !x.right.left.isRed()</span><br><span class="line">      x = moveRedRight(x)</span><br><span class="line">    <span class="keyword">if</span> key == x.key</span><br><span class="line">      minKey = min(x.right)</span><br><span class="line">      minVal = minKey.val</span><br><span class="line">      x.val = get(x.right, minVal)</span><br><span class="line">      x.key = minKey</span><br><span class="line">      x.right = deleteMin(x.right)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      x.right = <span class="keyword">delete</span>(x.right,key)</span><br><span class="line">  x = balance(x)</span><br><span class="line">  <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RedBlackBST-Review&quot;&gt;&lt;a href=&quot;#RedBlackBST-Review&quot; class=&quot;headerlink&quot; title=&quot;RedBlackBST Review&quot;&gt;&lt;/a&gt;RedBlackBST Review&lt;/h1&gt;&lt;p&gt;This is a review about RedBlackBST by CLRS#3 &amp;amp; Algorithm#4.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/categories/Algorithm/"/>
    
    
      <category term="review" scheme="http://yif-hong.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>BinarySearchTree Review</title>
    <link href="http://yif-hong.github.io/2020/09/13/BinarySearchTree-Review/"/>
    <id>http://yif-hong.github.io/2020/09/13/BinarySearchTree-Review/</id>
    <published>2020-09-13T03:00:00.000Z</published>
    <updated>2020-09-13T04:07:55.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BinarySearchTree-Review"><a href="#BinarySearchTree-Review" class="headerlink" title="BinarySearchTree Review"></a>BinarySearchTree Review</h1><p>This is a review about BinarySearchTree by CLRS#3 &amp; Algorithm#4.</p><a id="more"></a><h2 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h2><ul><li>Average function<br>$$<br>T(n) = \Theta(\lg{n})<br>$$</li></ul><h2 id="lt-CLRS-3-gt"><a href="#lt-CLRS-3-gt" class="headerlink" title="&lt;CLRS#3&gt;"></a>&lt;CLRS#3&gt;</h2><h3 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TREE-SEARCH(x,k)</span><br><span class="line"><span class="keyword">if</span> x == NIL <span class="keyword">or</span> k == x.key</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  <span class="keyword">if</span> k &lt; x.key</span><br><span class="line">    <span class="keyword">return</span> TREE-SEARCH(x.left,k)</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> TREE-SEARCH(x.right,k)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">INTERATICE-TREE-SEARCH(x,k)</span><br><span class="line"><span class="keyword">while</span> x != NIL <span class="keyword">and</span> k != x.key</span><br><span class="line">    <span class="keyword">if</span> k &lt; x.key</span><br><span class="line">      x = x.left</span><br><span class="line">    <span class="keyword">else</span> k &gt; x.key</span><br><span class="line">      x = x.right</span><br><span class="line">  <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TREE-MINIMUN(x)</span><br><span class="line">  <span class="keyword">while</span> x != NIL</span><br><span class="line">    x = x.left</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">TREE-MAXIMUN(x)</span><br><span class="line">  <span class="keyword">while</span> x != NIL</span><br><span class="line">    x = x.right</span><br><span class="line">  <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TREE-SUCCESSOR(x)</span><br><span class="line">  <span class="keyword">if</span> x.right != NIL</span><br><span class="line">    <span class="keyword">return</span> TREE-MAXIMUM(x.right)</span><br><span class="line">  y = x.p</span><br><span class="line">  <span class="keyword">while</span> y != NIL <span class="keyword">and</span> x == y.right</span><br><span class="line">    x = y</span><br><span class="line">    y = y.p</span><br><span class="line">  <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TREE-INSERT(T,z)</span><br><span class="line">  y = NIL</span><br><span class="line">  x = T.root</span><br><span class="line">  <span class="keyword">while</span> x != NIL</span><br><span class="line">    y = x</span><br><span class="line">    <span class="keyword">if</span> z.key &lt; x.key</span><br><span class="line">      x = x.left</span><br><span class="line">    <span class="keyword">else</span> x = x.right</span><br><span class="line">  z.p = y</span><br><span class="line">  <span class="keyword">if</span> y == NIL</span><br><span class="line">    T.root = z</span><br><span class="line">  elif z.key &lt; y.key</span><br><span class="line">    y.left = z</span><br><span class="line">  <span class="keyword">else</span> y.right = z</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TRANSPLANT(T,u,v)</span><br><span class="line">  <span class="keyword">if</span> u.p == NIL</span><br><span class="line">    T.root = v</span><br><span class="line">  elif u == u.p.left</span><br><span class="line">    u.p.left = v</span><br><span class="line">  <span class="keyword">else</span> u.p.right = v</span><br><span class="line">  <span class="keyword">if</span> v != NIL</span><br><span class="line">    v.p = u.p</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TREE-DELETE(T,z)</span><br><span class="line">  <span class="keyword">if</span> z.left == NIL</span><br><span class="line">    TRANSPLANT(T,z,z.right)</span><br><span class="line">  elif z.right == NIL</span><br><span class="line">    TRANSPLANT(T,z,z.left)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    y = TREE-MINIMUM(z.right)</span><br><span class="line">    <span class="keyword">if</span> y.p != NIL</span><br><span class="line">      TRANSPLANT(T,y,y.right)</span><br><span class="line">      y.right = z.right</span><br><span class="line">      y.right.p = y</span><br><span class="line">    TRANSPLANT(T,z,y)</span><br><span class="line">    y.left = z.left</span><br><span class="line">    y.left.p = y</span><br></pre></td></tr></table></figure><h2 id="lt-Algorithm-4-gt"><a href="#lt-Algorithm-4-gt" class="headerlink" title="&lt;Algorithm#4&gt;"></a>&lt;Algorithm#4&gt;</h2><h3 id="BST-1"><a href="#BST-1" class="headerlink" title="BST"></a>BST</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">  Key key</span><br><span class="line">  Value val</span><br><span class="line">  Node left, right</span><br><span class="line">  size <span class="comment">//intger</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">size():</span><br><span class="line"><span class="keyword">return</span> size(ROOT)</span><br><span class="line"></span><br><span class="line">size(node):</span><br><span class="line"><span class="keyword">if</span> node == NIL</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> size(node.left) + size(node.right) + <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">get(Key):</span><br><span class="line"><span class="keyword">return</span> get(ROOT,Key)</span><br><span class="line"></span><br><span class="line">get(node,key):</span><br><span class="line"><span class="keyword">if</span> key == NIL</span><br><span class="line">    <span class="keyword">return</span> NIL</span><br><span class="line">  elif key &lt; node.key</span><br><span class="line">    <span class="keyword">return</span> get(node.left,key)</span><br><span class="line">  elif key &gt; node.key</span><br><span class="line">    <span class="keyword">return</span> get(node.right,key)</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> node.val</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">put(Key,VALUE):</span><br><span class="line">put(ROOT,KEY,VALUE)</span><br><span class="line"></span><br><span class="line">put(node,key,val):</span><br><span class="line"><span class="keyword">if</span> node == NIL</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Node(key,val,<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">if</span> key &lt; node.key</span><br><span class="line">    put(node.left,key,val)</span><br><span class="line">  elif key &gt; node.key</span><br><span class="line">    put(node.right,key,val)</span><br><span class="line">  <span class="keyword">else</span> node.val = val</span><br><span class="line">  node.size = size(node.left) + size(node.right) + <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">max():</span><br><span class="line"><span class="keyword">return</span> max(ROOT)</span><br><span class="line"></span><br><span class="line">max(node):</span><br><span class="line"><span class="keyword">if</span> node.right == NIL</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"><span class="keyword">return</span> max(node.right)</span><br><span class="line"></span><br><span class="line">min():</span><br><span class="line"><span class="keyword">return</span> min(ROOT)</span><br><span class="line"></span><br><span class="line">min(node):</span><br><span class="line"><span class="keyword">if</span> min.left == NIL</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"><span class="keyword">return</span> min(node.right)</span><br><span class="line"></span><br><span class="line"><span class="comment">// round down</span></span><br><span class="line"><span class="built_in">floor</span>(KEY):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">floor</span>(ROOT,KEY)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">floor</span>(node,key):</span><br><span class="line"><span class="keyword">if</span> node == NIL</span><br><span class="line">    <span class="keyword">return</span> NIL</span><br><span class="line">  <span class="keyword">if</span> key == node.key</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  elif key &lt; node.key</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">floor</span>(node.left,key)</span><br><span class="line">  t = <span class="built_in">floor</span>(node.right,key)</span><br><span class="line">  <span class="keyword">if</span> t == NIL</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"><span class="comment">// round up</span></span><br><span class="line">ceiling(KEY):</span><br><span class="line"><span class="keyword">return</span> ceiling(ROOT,KEY)</span><br><span class="line">    </span><br><span class="line">ceiling(node,key):</span><br><span class="line"><span class="keyword">if</span> node == NIL</span><br><span class="line">    <span class="keyword">return</span> NIL</span><br><span class="line">  <span class="keyword">if</span> key == node.key</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  elif key &gt; node.key</span><br><span class="line">    <span class="keyword">return</span> ceiling(node.right,key)</span><br><span class="line">  t = ceiling(node.left,key)</span><br><span class="line">  <span class="keyword">if</span> t == NIL</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"><span class="comment">// find rank k node</span></span><br><span class="line">select(k):</span><br><span class="line">select(ROOT,k)</span><br><span class="line"></span><br><span class="line">select(node,k):</span><br><span class="line"><span class="keyword">if</span> node == NIL</span><br><span class="line">    <span class="keyword">return</span> NIL</span><br><span class="line">  t = node.left.size</span><br><span class="line">  <span class="keyword">if</span> k &lt; t</span><br><span class="line">    <span class="keyword">return</span> select(node.left,k)</span><br><span class="line">  elif k &gt; t</span><br><span class="line">    <span class="keyword">return</span> select(node.right,k-t<span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="comment">// find size of smaller than KEY</span></span><br><span class="line">rank(KEY):</span><br><span class="line">rank(ROOT,KEY)</span><br><span class="line">    </span><br><span class="line">rank(node,key):</span><br><span class="line"><span class="keyword">if</span> node == NIL</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> key &lt; node.key</span><br><span class="line">    <span class="keyword">return</span> rank(node.left,key)</span><br><span class="line">  elif k &gt; node.key</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + size(node.left) + rank(node.right.key)</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> node.left.size</span><br><span class="line"></span><br><span class="line"><span class="comment">// just delete min node</span></span><br><span class="line">deleteMin():</span><br><span class="line"><span class="keyword">return</span> deleteMin(ROOT)</span><br><span class="line">    </span><br><span class="line">deleteMin(node):</span><br><span class="line"><span class="keyword">if</span> node.left == NIL</span><br><span class="line">    <span class="keyword">return</span> node.right</span><br><span class="line">  node.left = deleteMin(node.left)</span><br><span class="line">  node.size = size(node.left) + size(node.right) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line"><span class="comment">// just delete max node</span></span><br><span class="line">deleteMax():</span><br><span class="line">   <span class="keyword">return</span> deleteMax(ROOT)</span><br><span class="line">    </span><br><span class="line">deleteMax(node):</span><br><span class="line"><span class="keyword">if</span> node.right == NIL</span><br><span class="line">    <span class="keyword">return</span> node.left</span><br><span class="line">  node.right = deleteMax(node.right)</span><br><span class="line">  node.size = size(node.left) + size(node.right) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line"><span class="comment">// delete KEY</span></span><br><span class="line"><span class="keyword">delete</span>(KEY):</span><br><span class="line"><span class="keyword">delete</span>(ROOT,KEY)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">delete</span>(node,key):</span><br><span class="line"><span class="keyword">if</span> node == NIL</span><br><span class="line">    <span class="keyword">return</span> NIL</span><br><span class="line">  <span class="keyword">if</span> key &lt; node.key</span><br><span class="line">    node.left = <span class="keyword">delete</span>(node.left,key)</span><br><span class="line">  elif key &gt; node.key</span><br><span class="line">    node.right = <span class="keyword">delete</span>(node.right,key)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> node.right == NIL</span><br><span class="line">      <span class="keyword">return</span> node.left</span><br><span class="line">    <span class="keyword">if</span> node.left == NIL</span><br><span class="line">      <span class="keyword">return</span> node.right</span><br><span class="line">    successor = min(node.right)</span><br><span class="line">    successor.right = deleteMin(node.right)</span><br><span class="line">    successor.left = node.left</span><br><span class="line">  successor.size = size(successor.left) + size(successor.right) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> successor</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BinarySearchTree-Review&quot;&gt;&lt;a href=&quot;#BinarySearchTree-Review&quot; class=&quot;headerlink&quot; title=&quot;BinarySearchTree Review&quot;&gt;&lt;/a&gt;BinarySearchTree Review&lt;/h1&gt;&lt;p&gt;This is a review about BinarySearchTree by CLRS#3 &amp;amp; Algorithm#4.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/categories/Algorithm/"/>
    
    
      <category term="review" scheme="http://yif-hong.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>HeapSort Review</title>
    <link href="http://yif-hong.github.io/2020/09/13/HeapSort-Review/"/>
    <id>http://yif-hong.github.io/2020/09/13/HeapSort-Review/</id>
    <published>2020-09-13T02:00:00.000Z</published>
    <updated>2020-09-13T02:24:15.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HeapSort-Review"><a href="#HeapSort-Review" class="headerlink" title="HeapSort Review"></a>HeapSort Review</h1><p>This is a review about HeapSort by CLRS#3 &amp; Algorithm#4.</p><a id="more"></a><h2 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h2><ul><li>Average<br>$$<br>T(n) = \Theta(n\lg{n})<br>$$</li></ul><h2 id="lt-CLRS-3-gt"><a href="#lt-CLRS-3-gt" class="headerlink" title="&lt;CLRS#3&gt;"></a>&lt;CLRS#3&gt;</h2><h3 id="MAX-HEAPIFY"><a href="#MAX-HEAPIFY" class="headerlink" title="MAX_HEAPIFY"></a>MAX_HEAPIFY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MAX_HEAPIFY(A,i):</span><br><span class="line">l &#x3D; LEFT(A,i)</span><br><span class="line">r &#x3D; RIGHT(A,i)</span><br><span class="line">if l &lt;&#x3D; A.heap-size &amp;&amp; A[l] &gt; A[i]</span><br><span class="line">largest &#x3D; l</span><br><span class="line">else largest &#x3D; i</span><br><span class="line">if r &lt;&#x3D; A.heap-size &amp;&amp; A[l] &gt; A[largest]</span><br><span class="line">largest &#x3D; r</span><br><span class="line">if largest !&#x3D; i</span><br><span class="line">exchange A[i] with A[largest]</span><br><span class="line">MAX_HEAPIFY(A,largest)</span><br></pre></td></tr></table></figure><h3 id="BuildMaxHeap"><a href="#BuildMaxHeap" class="headerlink" title="BuildMaxHeap"></a>BuildMaxHeap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BuildMaxHeap(A):</span><br><span class="line">A.heap-size &#x3D; A.length</span><br><span class="line">for i &#x3D; A.length&#x2F;2 to 1</span><br><span class="line">MAX_HEAPIFY(A,i)</span><br></pre></td></tr></table></figure><h2 id="lt-Algorithm-4-gt"><a href="#lt-Algorithm-4-gt" class="headerlink" title="&lt;Algorithm#4&gt;"></a>&lt;Algorithm#4&gt;</h2><h3 id="HeapSort"><a href="#HeapSort" class="headerlink" title="HeapSort"></a>HeapSort</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">swim(A,k):</span><br><span class="line"><span class="keyword">if</span> k &gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> A[k] &gt; A[k/<span class="number">2</span>]</span><br><span class="line">      exchange A[k] with A[k/<span class="number">2</span>]</span><br><span class="line">      swim(A,k/<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sink(A,k):</span><br><span class="line"><span class="keyword">if</span> k &lt; A.length/<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> A[k] &lt; A[k*<span class="number">2</span>]</span><br><span class="line">      exchange A[k] with A[k*<span class="number">2</span>]</span><br><span class="line">      sink(a,k*<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BuildMaxHeap(A):</span><br><span class="line">for i &#x3D; A.length&#x2F;2 to 1</span><br><span class="line">sink(A,i)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HeapSort-Review&quot;&gt;&lt;a href=&quot;#HeapSort-Review&quot; class=&quot;headerlink&quot; title=&quot;HeapSort Review&quot;&gt;&lt;/a&gt;HeapSort Review&lt;/h1&gt;&lt;p&gt;This is a review about HeapSort by CLRS#3 &amp;amp; Algorithm#4.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/categories/Algorithm/"/>
    
    
      <category term="review" scheme="http://yif-hong.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>MergeSort Review</title>
    <link href="http://yif-hong.github.io/2020/09/12/MergeSort-Review/"/>
    <id>http://yif-hong.github.io/2020/09/12/MergeSort-Review/</id>
    <published>2020-09-12T14:00:00.000Z</published>
    <updated>2020-09-13T02:24:39.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MergeSort-Review"><a href="#MergeSort-Review" class="headerlink" title="MergeSort Review"></a>MergeSort Review</h1><p>This is a review about MergeSort by CLRS#3 &amp; Algorithm#4.</p><a id="more"></a><h2 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h2><ul><li>Average<br>$$<br>T(n) = \Theta(n\lg{n})<br>$$</li></ul><h2 id="lt-CLRS-3-gt"><a href="#lt-CLRS-3-gt" class="headerlink" title="&lt;CLRS#3&gt;"></a>&lt;CLRS#3&gt;</h2><p>$$<br>T(n)=2T(n/2)+\Theta(n)<br>$$</p><h3 id="Main-Function"><a href="#Main-Function" class="headerlink" title="Main Function"></a>Main Function</h3><p>$$<br>T(n)=aT(n/b)+f(n)<br>$$</p><p>$$<br>1.\ T(n)=\Theta(n^{\log_b{a}}),\ if\ f(n)=n^{\log_{b}a - \varepsilon},\varepsilon&gt;0.\<br>$$<br>$$<br>2.\ T(n)=\Theta(n\lg{n}),\ if\ f(n)=n^{\log_{b}a}.\<br>$$<br>$$<br>3.\ T(n)=\Theta(f(n)),\ if\ f(n)=n^{\log_{b}a + \varepsilon},\varepsilon&gt;0.<br>$$</p><h2 id="lt-Algorithm-4-gt"><a href="#lt-Algorithm-4-gt" class="headerlink" title="&lt;Algorithm#4&gt;"></a>&lt;Algorithm#4&gt;</h2><h3 id="MergeSort"><a href="#MergeSort" class="headerlink" title="MergeSort"></a>MergeSort</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">merge(A,lo,mid,hi):</span><br><span class="line">copy B by A from lo to hi</span><br><span class="line">i = lo</span><br><span class="line">j = mid+<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> k = lo to hi</span><br><span class="line"><span class="keyword">if</span> i&gt;mid</span><br><span class="line">A[k] = B[j++]</span><br><span class="line">elif j&gt;hi</span><br><span class="line">A[k] = B[i++]</span><br><span class="line">elif B[j]&lt;B[i]</span><br><span class="line">A[k] = B[j++]</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">A[k] = B[i++]</span><br><span class="line"></span><br><span class="line">sort(A,lo,hi):</span><br><span class="line"><span class="keyword">if</span> lo&gt;=hi</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">mid = lo + (hi-lo)/<span class="number">2</span></span><br><span class="line">sort(A,lo,mid)</span><br><span class="line">sort(A,mid+<span class="number">1</span>,hi)</span><br><span class="line">merge(A,lo,mid,hi)</span><br><span class="line"></span><br><span class="line">sort(A,<span class="number">1</span>,A.length)</span><br></pre></td></tr></table></figure><h3 id="MergeSortBU"><a href="#MergeSortBU" class="headerlink" title="MergeSortBU"></a>MergeSortBU</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sortBU(A):</span><br><span class="line"><span class="keyword">for</span> sz = <span class="number">1</span> to N <span class="comment">//sub-array size</span></span><br><span class="line"><span class="keyword">for</span>i = <span class="number">1</span> to N-sz <span class="comment">//sub array start</span></span><br><span class="line">merge(A,i,i+sz<span class="number">-1</span>,Math.min(N,i+sz+sz<span class="number">-1</span>))</span><br><span class="line">i = i + sz + sz <span class="comment">//next sub array start</span></span><br><span class="line">sz = sz + sz + sz <span class="comment">//expand sub-array size</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MergeSort-Review&quot;&gt;&lt;a href=&quot;#MergeSort-Review&quot; class=&quot;headerlink&quot; title=&quot;MergeSort Review&quot;&gt;&lt;/a&gt;MergeSort Review&lt;/h1&gt;&lt;p&gt;This is a review about MergeSort by CLRS#3 &amp;amp; Algorithm#4.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/categories/Algorithm/"/>
    
    
      <category term="review" scheme="http://yif-hong.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>QuickSort Review</title>
    <link href="http://yif-hong.github.io/2020/09/12/QuickSort-Review/"/>
    <id>http://yif-hong.github.io/2020/09/12/QuickSort-Review/</id>
    <published>2020-09-12T09:32:51.000Z</published>
    <updated>2020-09-13T02:24:34.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QuickSort-Review"><a href="#QuickSort-Review" class="headerlink" title="QuickSort Review"></a>QuickSort Review</h1><p>This is a review about QuickSort by CLRS#3 &amp; Algorithm#4.</p><a id="more"></a><h2 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h2><ul><li>Best:       O(nlgn)     </li><li>Average:    O(nlgn)     random inputs</li><li>Bad:        O(n^2)      sorted inputs, repeat inputs</li></ul><h2 id="lt-CLRS-3-gt"><a href="#lt-CLRS-3-gt" class="headerlink" title="&lt;CLRS#3&gt;"></a>&lt;CLRS#3&gt;</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sort(A,1,A.length)</span><br><span class="line"></span><br><span class="line">sort(A,p,r):</span><br><span class="line">    if p &lt; r</span><br><span class="line">        q &#x3D; partition(A,p,r)</span><br><span class="line">        sort(A,p,q-1)</span><br><span class="line">        sort(A,q+1,r)</span><br><span class="line"></span><br><span class="line">partition(A,p,r):</span><br><span class="line">    x &#x3D; A[r]</span><br><span class="line">    i &#x3D; p-1</span><br><span class="line">    for j &#x3D; p to r-1:</span><br><span class="line">        if A[j] &lt;&#x3D; x:</span><br><span class="line">            i &#x3D; i + 1</span><br><span class="line">            exchange A[i] with A[j]</span><br><span class="line">    exchange A[i+1] with A[r]</span><br><span class="line">    return i+1</span><br></pre></td></tr></table></figure><h2 id="lt-Algorithm-4-gt"><a href="#lt-Algorithm-4-gt" class="headerlink" title="&lt;Algorithm#4&gt;"></a>&lt;Algorithm#4&gt;</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sort(A,1,A.length)</span><br><span class="line"></span><br><span class="line">sort(A,p,r):</span><br><span class="line">    if p &lt; r</span><br><span class="line">        q &#x3D; partition(A,p,r)</span><br><span class="line">        sort(A,p,q-1)</span><br><span class="line">        sort(A,q+1,r)</span><br><span class="line"></span><br><span class="line">partition(A,p,r):</span><br><span class="line">    x &#x3D; A[p]</span><br><span class="line">    i &#x3D; p</span><br><span class="line">    j &#x3D; r+1</span><br><span class="line">    while i &lt; j</span><br><span class="line">        while A[i] &lt; x</span><br><span class="line">            i &#x3D; i+1</span><br><span class="line">            if i &#x3D;&#x3D; r</span><br><span class="line">                break</span><br><span class="line">        while A[j] &gt; x</span><br><span class="line">            j &#x3D; j-1</span><br><span class="line">            if j &#x3D;&#x3D; p</span><br><span class="line">                break</span><br><span class="line">        exchange A[i] with A[j]</span><br><span class="line">    exchange A[j] with A[p]</span><br><span class="line">    return j</span><br></pre></td></tr></table></figure><h3 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h3><ol><li>Change to Insertion-Sort while sub-array’s item less than 5~15</li><li>Quick partition: Find middle item and set size 3 to make partition.</li><li>Dijkstra: [Quick3Way] for repeat inputs. Best O(N). Bad O(NlgN)<h4 id="Quick3Way"><a href="#Quick3Way" class="headerlink" title="Quick3Way"></a>Quick3Way</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sort(A,1,A.length)</span><br><span class="line"></span><br><span class="line">sort(A,p,r):</span><br><span class="line">    if p &lt; r</span><br><span class="line">        &#x2F;&#x2F; [p,lt) &lt;&#x3D; [lt,gt) &lt;&#x3D; [gt,r]</span><br><span class="line">        lt &#x3D; p</span><br><span class="line">        gt &#x3D; r</span><br><span class="line">        i &#x3D; p+1</span><br><span class="line">        x &#x3D; a[p]</span><br><span class="line">        while i &lt;&#x3D; gt</span><br><span class="line">            if A[i] &lt; p</span><br><span class="line">                exchange A[lt] with A[i]</span><br><span class="line">                lt &#x3D; lt+1</span><br><span class="line">                i &#x3D; i+1</span><br><span class="line">            else if A[i] &gt; p</span><br><span class="line">                exchange A[i] with A[gt]</span><br><span class="line">                gt &#x3D; gt-1</span><br><span class="line">            else</span><br><span class="line">                i &#x3D; i+1</span><br><span class="line">    sort(A,p,lt-1)</span><br><span class="line">    sort(A,gt+1,r)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;QuickSort-Review&quot;&gt;&lt;a href=&quot;#QuickSort-Review&quot; class=&quot;headerlink&quot; title=&quot;QuickSort Review&quot;&gt;&lt;/a&gt;QuickSort Review&lt;/h1&gt;&lt;p&gt;This is a review about QuickSort by CLRS#3 &amp;amp; Algorithm#4.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/categories/Algorithm/"/>
    
    
      <category term="review" scheme="http://yif-hong.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>排序算法——基于比较的算法</title>
    <link href="http://yif-hong.github.io/2018/09/29/BaseSort/"/>
    <id>http://yif-hong.github.io/2018/09/29/BaseSort/</id>
    <published>2018-09-29T10:52:28.000Z</published>
    <updated>2020-09-12T08:12:15.277Z</updated>
    
    <content type="html"><![CDATA[<p>基础排序算法涉及到<strong>选择（冒泡）排序、插入排序、希尔排序、归并排序、快速排序、堆排序、优先队列</strong>，这几种算法分别拥有不同的特点及实现，下面就简单介绍一下。</p><a id="more"></a><h3 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h3><p>在统一介绍之前，利用Java特性，这里先抽象出几个公共的方法特性。另外，所有元素都实现了<code>Comparable</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseSort</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> a[i].compareTo(a[j]) &lt; <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">           Comparable temp =a[i];</span><br><span class="line">           a[i] = a[j];</span><br><span class="line">           a[j] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序是对冒泡排序的一种改进，减少了交换次数。以从小到大的排序为例，从第一位开始，依次向后遍历并将剩余数组中最小的元素交换到遍历的起点。</p><ul><li>从起点遍历，依次减小遍历范围</li><li>找出遍历的剩余数组中的最小值</li><li>与遍历起点交换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> <span class="keyword">extends</span> <span class="title">BaseSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++)</span><br><span class="line">                <span class="keyword">if</span> (less(a, j, min)) min = j;</span><br><span class="line">            exchange(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>性能：比较 N^2/2 + 交换 3/2 N，最差情况<strong>N^2级别</strong></p></blockquote><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序可以理解为打扑克牌时的动作，将牌插入手中牌堆合适的位置。</p><p>以从小到大的排序为例，如果此时插入的牌在手牌中第一次找到了比他小的牌，那么此时位置确定，因为前面的牌都比要插入的小，且已排好顺序。</p><ul><li>第一位不用排序</li><li>第二位开始与前面的元素进行比较</li><li>若比他前一位小，则交换位置</li><li>找到第一个比他小的，即确定位置</li><li>遍历直至最后</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> <span class="keyword">extends</span> <span class="title">BaseSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a, j, j - <span class="number">1</span>); j--)</span><br><span class="line">                exchange(a, j, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>性能：比较 N^2/4 + 交换 N^2/4 ，最差情况<strong>N^2级别</strong></p></blockquote><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>插入排序面对数据量较小时还可以，但是对于数据偏大则有些力不从心了。希尔排序是针对插入排序的一种优化切分算法，采用分治思想。时间复杂度突破了N^2级别，但是空间复杂度却能保持O (1)。而快速排序算法采用的辅助栈则在空间上无法比拟希尔排序。</p><ul><li>先将序列分成较多个子序列分别进行排序，再分成较少个子序列分别进行排序，直到最后为一个序列排序</li><li>子序列的排序使用插入排序</li></ul><p>这里的子序列是通过增量h来分割的，每隔h位形成一个有序的子序列。这里采用1/3切分，性能较好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> <span class="keyword">extends</span> <span class="title">BaseSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; a.length / <span class="number">3</span>) h = h * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; a.length; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; h &amp;&amp; less(a, j, j - h); j -= h)</span><br><span class="line">                    exchange(a, j, j - h);</span><br><span class="line">            h /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>性能：在 <strong>NlogN 和 N^2</strong> 之间。</p></blockquote><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是典型的分治思想算法，通过将数组分为各个小数组并排序后合并实现有序。</p><p>由于归并排序总是将数组分为2个子数组，所以，在算法执行的过程中可以将其排序视作二叉树，其算法所需的复杂度也在NlogN级别。</p><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>合并是将两个有序的数组合并成一个有序的大数组，这是归并排序的基石。</p><p>借助辅助数组<code>aux[]</code>，将原数组复制到<code>aux[]</code>中，然后依次复制回原数组中，将<code>a[lo...mid]</code>和<code>a[mid+1...hi]</code>归并。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> <span class="keyword">extends</span> <span class="title">BaseSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt; hi; k++)</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++)</span><br><span class="line">            <span class="keyword">if</span> (j &gt; hi) a[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; mid) a[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (less(a, j, i)) a[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> a[k] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自顶向下的归并"><a href="#自顶向下的归并" class="headerlink" title="自顶向下的归并"></a>自顶向下的归并</h4><p>对于一个大数组，自然而然的可以考虑使用将其分为两个小数组进行排序然后归并，子数组再次分裂……直至只有两个元素的子数组，此时开始收敛，向上归并。</p><ul><li><strong>化整为零</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeUBSort</span> <span class="keyword">extends</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        sort(a, lo, mid);</span><br><span class="line">        sort(a, mid + <span class="number">1</span>, hi);</span><br><span class="line">        merge(a, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于小规模的子数组可以采用<strong>插入排序</strong>进行优化，一般可以提高10%左右的性能。</p><p>同时也可以不将元素复制到辅助数组，减少复制到辅助数组的时间开销，但是空间无法减小，这也是归并排序的缺陷之一。</p><blockquote><p>性能：1/2NlogN~NlogN</p></blockquote><h4 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h4><p>在分治思想中，我们处理的问题大多都由大问题转化为小问题，故干脆可以直接从小问题处理入手，转而合并为大问题。</p><ul><li><strong>循序渐进</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeBUSort</span> <span class="keyword">extends</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; a.length; sz += sz)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; a.length - sz; lo += sz + sz)</span><br><span class="line">                merge(a, lo, lo + sz - <span class="number">1</span>, Math.min(a.length - <span class="number">1</span>, lo + sz + sz - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码进行logN次的两两归并。</p><blockquote><p>性能：1/2NlogN~NlogN。</p></blockquote><ul><li>自底向上在数组大小为2的幂时，与自顶向下性能一样，只是访问顺序不同。</li><li>自底向上更适合使用链表作为数据结构排序。</li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序利用分治思想，将首位作为标杆，将比他小的放在左边，比他大的放在右边。然后再对两个子数组进行排序。</p><p>最终</p><p>这里采用指针探测法实现。</p><h4 id="切分-partition"><a href="#切分-partition" class="headerlink" title="切分 partition"></a>切分 partition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (less(a, ++i, lo)) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (less(a, lo, --j)) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;<span class="comment">//可不必判断</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        exchange(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    exchange(a, lo, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用头尾两个指针i和j，以数组第一位元素v为标杆。</li><li>若i比v小，则继续遍历，直至比v大停止。</li><li>若j比v大，则继续遍历，直至比v小停止。</li><li>交换i和j。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> <span class="keyword">extends</span> <span class="title">BaseSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">        sort(a, lo, j - <span class="number">1</span>);</span><br><span class="line">        sort(a, j + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>性能：一般情况 NlogN ，最差情况<strong>N^2级别</strong>。</p></blockquote><h4 id="快速排序优化"><a href="#快速排序优化" class="headerlink" title="快速排序优化"></a>快速排序优化</h4><p>快速排序在重复数据较小或随机排列数据较多时性能比较好，若在重复数据多，则此时最差情况可达到N^2级别。为此，针对快速排序的优化算法也是十分重要的一点。</p><h5 id="小数组使用插入排序"><a href="#小数组使用插入排序" class="headerlink" title="小数组使用插入排序"></a>小数组使用插入排序</h5><p>插入排序在小数组时性能不错，而对于快排来说，小数组的性能反而不佳。对于小数组的界定一般在5~15之间，具体依据操作系统优化而定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> <span class="keyword">extends</span> <span class="title">BaseSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;<span class="comment">//5~15依据操作系统而定</span></span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &gt;= lo + MAX) &#123;</span><br><span class="line">         <span class="keyword">new</span> InsertionSort.sort(a, lo, hi);<span class="comment">//转向插入排序</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="三向切分优化重复数组的性能"><a href="#三向切分优化重复数组的性能" class="headerlink" title="三向切分优化重复数组的性能"></a>三向切分优化重复数组的性能</h5><p>维护lt和gt两个指针，从左右向中心遍历，维护切分区域。通过与i遍历指针交换，使得lo<del>lt &lt; lt</del>gt &lt; gt~hi。对于大量重复的数组，此种方法可以减少大量的交换开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quick3WaySort</span> <span class="keyword">extends</span> <span class="title">BaseSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> lt = lo, gt = hi, i = lt + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">            <span class="keyword">int</span> comp = a[i].compareTo(a[lo]);</span><br><span class="line">            <span class="keyword">if</span> (comp &lt; <span class="number">0</span>) exchange(a, i++, lt++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (comp &gt; <span class="number">0</span>) exchange(a, i, gt--);</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, lo, lt - <span class="number">1</span>);</span><br><span class="line">        sort(a, gt + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然三向切分也可以使用插入排序优化性能。</p><blockquote><p>性能：在大小为N，主键值出现的频率为H，性能为**~NH<strong>。<br>**在重复键值较多的情况下，可以将性能由N^2优化至N级别。</strong></p></blockquote><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序的实现基础是在二叉堆上完成的。</p><h4 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h4><p>二叉堆是一种完全（或近似）二叉树。其两个子结点一定大于（小于）或等于父结点。大于或小于取决于是最大堆还是最小堆。</p><ul><li>在一个父节点为k的位置，其子结点为2k 和2k+1。</li></ul><p>利用这个性质，在二叉堆中上下移动只需要将k/2或k=2*k即可。</p><p><img src="http://pdjydlit1.bkt.clouddn.com/heap-representations.png" alt="二叉堆结构"></p><p>这里的实现我们是以数组为基础的数据结构实现的。</p><p>因为无法完成上下移动，所以<strong>数组第0个位置是不存放数据以及使用的！</strong></p><p>在之后的操作中，我们以最大堆为例子。（最小堆仅仅是比较大小的方向不同）</p><h4 id="堆的基础算法"><a href="#堆的基础算法" class="headerlink" title="堆的基础算法"></a>堆的基础算法</h4><p>在对堆进行添加删除操作时，需要对堆进行恢复，此时需要借助两个辅助操作。</p><ul><li>如果此时某个结点的优先级上升，则此时需要从下至上恢复堆——上浮 swim</li><li>如果此时某个结点的优先级下降，则此时需要从上至下恢复堆——下沉 sink</li></ul><h5 id="上浮-swim"><a href="#上浮-swim" class="headerlink" title="上浮 swim"></a>上浮 swim</h5><p>如果某个子结点比其父结点优先级更高，则此时需要子结点中优先级最高的与其父结点交换，进行上浮，直至到合适位置（堆顶或不再更大）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(Comparable[] a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(a, k / <span class="number">2</span>, k)) &#123;</span><br><span class="line">        exchange(a, k / <span class="number">2</span>, k);</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="下沉-sink"><a href="#下沉-sink" class="headerlink" title="下沉 sink"></a>下沉 sink</h5><p>如果某个父结点比其子结点优先级更低，则此时需要父结点与子节点中优先级最高的交换，进行下沉，直至到合适位置（堆底部或不再更小）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k * <span class="number">2</span> &lt;= a.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = k * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; a.length - <span class="number">1</span> &amp;&amp; less(a, j, j + <span class="number">1</span>)) j++;</span><br><span class="line">        <span class="keyword">if</span> (!less(a, k, j)) <span class="keyword">break</span>;</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆排序实现"><a href="#堆排序实现" class="headerlink" title="堆排序实现"></a>堆排序实现</h4><p>堆排序的实现分为两步：</p><ul><li>构造堆序列</li><li>通过下沉操作不断的返回堆顶值（最大/小值）至数组末尾，形成有序数列。</li></ul><blockquote><p>给定一个数组，将其排序为堆排序，则是构造堆。<br>此过程中，可以用上浮和下沉实现。但是<strong>下沉操作仅需2N次比较以及小于N次交换</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeapSort</span> <span class="keyword">extends</span> <span class="title">BaseSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">            sink(a, k);</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            exchange(a, <span class="number">1</span>, N--);</span><br><span class="line">            sink(a, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(Comparable[] a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>性能：堆排序可以达到稳定的<strong>NlogN</strong>开销和恒定的额外空间。<br>劣势：对于一些空间紧张的情况而言，可以很简洁的实现较好的性能。但是在现代操作系统中使用较少，因为其无法利用缓存。这是其相对于快速排序、希尔排序、归并排序的劣势。<br>通过堆实现的优先队列非常重要，因为其能很好的将插入和删除最大（最小）元素的操作保证对数级开销。</p></blockquote><p><em>可以通过先下沉后上浮的方式，优化算法，减少接近一半的比较次数，但是会损失额外的空间。</em></p><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><blockquote><p>优先队列是基于堆的完全二叉树表示</p></blockquote><p>其将数据存储于<code>pq[1...N]</code>中，<code>pq[0]</code>未使用。</p><ul><li>构造器可以传入数组或Collection作为参数，只需将其按照堆构造方法自底向上依次进行下沉即可。</li></ul><h4 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示优先级更高的比较，这里允许传入自定义的比较器修改优先级，默认最小优先队列</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">greater</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (comparator == <span class="keyword">null</span>) <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span> comparator.compare(pq[i], pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">          Key temp = pq[i];</span><br><span class="line">          pq[i] = pq[j];</span><br><span class="line">          pq[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">          Key[] copy = (Key[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">              copy[i] = pq[i];</span><br><span class="line">          &#125;</span><br><span class="line">          pq = copy;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>同样排序也需要下沉和上浮的操作进行辅助。实现和堆排序中类似，键值<code>key</code>实现了<code>Comparable</code>接口，使用一个<code>pq</code>数组维护，N表示真实数组填充的数据。</p><h4 id="上浮-swim-1"><a href="#上浮-swim-1" class="headerlink" title="上浮 swim"></a>上浮 swim</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; greater(k, k / <span class="number">2</span>)) &#123;</span><br><span class="line">        exchange(k, k / <span class="number">2</span>);</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="下沉-sink-1"><a href="#下沉-sink-1" class="headerlink" title="下沉 sink"></a>下沉 sink</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k * <span class="number">2</span> &gt;= N) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = k * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; N - <span class="number">1</span> &amp;&amp; greater(j + <span class="number">1</span>, j)) j++;</span><br><span class="line">        <span class="keyword">if</span> (!greater(j, k)) <span class="keyword">break</span>;</span><br><span class="line">        exchange(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-insert"><a href="#添加-insert" class="headerlink" title="添加 insert"></a>添加 insert</h4><p>只需将要添加的元素放入队尾，然后上浮到合适位置即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == pq.length - <span class="number">1</span>) resize(pq.length * <span class="number">2</span>);</span><br><span class="line">    pq[++N] = key;</span><br><span class="line">    swim(N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除最小值（优先级最高）"><a href="#删除最小值（优先级最高）" class="headerlink" title="删除最小值（优先级最高）"></a>删除最小值（优先级最高）</h4><p>将队列的最小值即数组的第1位返回，并与最后一位交换（置空），将新的首位元素下沉至合适位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">deletMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Key min = pq[<span class="number">1</span>];</span><br><span class="line">    exchange(<span class="number">1</span>, N--);</span><br><span class="line">    sink(<span class="number">1</span>);</span><br><span class="line">    pq[N + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (N == (pq.length - <span class="number">1</span>) / <span class="number">4</span>) resize(pq.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">private</span> Comparator&lt;? <span class="keyword">super</span> Key&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> maxN)</span> </span>&#123;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> Object[maxN + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> Key&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> maxN, Comparator&lt;? <span class="keyword">super</span> Key&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(maxN);</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setComparator</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> Key&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == pq.length - <span class="number">1</span>) resize(pq.length * <span class="number">2</span>);</span><br><span class="line">        pq[++N] = key;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">deletMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Key min = pq[<span class="number">1</span>];</span><br><span class="line">        exchange(<span class="number">1</span>, N--);</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        pq[N + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (N == (pq.length - <span class="number">1</span>) / <span class="number">4</span>) resize(pq.length / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; greater(k, k / <span class="number">2</span>)) &#123;</span><br><span class="line">            exchange(k, k / <span class="number">2</span>);</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k * <span class="number">2</span> &gt;= N) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = k * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; N - <span class="number">1</span> &amp;&amp; greater(j + <span class="number">1</span>, j)) j++;</span><br><span class="line">            <span class="keyword">if</span> (!greater(j, k)) <span class="keyword">break</span>;</span><br><span class="line">            exchange(k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">greater</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator == <span class="keyword">null</span>) <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> comparator.compare(pq[i], pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Key temp = pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        Key[] copy = (Key[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            copy[i] = pq[i];</span><br><span class="line">        &#125;</span><br><span class="line">        pq = copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul><li><strong>增加、删除操作均在logN级别内。</strong></li></ul><h3 id="索引优先队列"><a href="#索引优先队列" class="headerlink" title="索引优先队列"></a>索引优先队列</h3><p>在实现优先队列的基础之上，可以额外维护一个逆序数组<code>qp[]</code>使其能快速访问队列中任意元素（键值<code>key</code>）。</p><p>其中<code>qp[pq[i]] = pq[qp[i]] = key</code>。</p><blockquote><p>为了能够快速找到<code>pq[]</code>中元素值对应的下标，我们需要额外设置一个数组<code>qp[]</code>，它的作用是存储与对象相关的整数在<code>pq[]</code>数组中的下标，并在上浮和下沉的过程中同时维护它。</p></blockquote><p><img src="http://pdjydlit1.bkt.clouddn.com/IndexPQ.jpg" alt="索引优先队列结构"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>与优先队列不同的是，这里采用整数数组<code>pq[]</code>维护索引下标以及其堆的顺序，用<code>pq[]</code>维护元素与索引对应的位置关系，用额外的<code>keys[]</code>维护元素队列，<code>keys</code>中的数据位置不做改变。</p><ul><li>将<code>qp[]</code>初始化为-1，可以快速判断某位置是否包含元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexPriorityQueue</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] pq;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] qp;</span><br><span class="line">        <span class="keyword">private</span> Key[] keys;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">        <span class="keyword">private</span> Comparator&lt;? <span class="keyword">super</span> Key&gt; comparator;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IndexPriorityQueue</span><span class="params">(<span class="keyword">int</span> maxN)</span> </span>&#123;</span><br><span class="line">            N = <span class="number">0</span>;</span><br><span class="line">            pq = <span class="keyword">new</span> <span class="keyword">int</span>[maxN + <span class="number">1</span>];</span><br><span class="line">            qp = <span class="keyword">new</span> <span class="keyword">int</span>[maxN + <span class="number">1</span>];</span><br><span class="line">            keys = (Key[]) <span class="keyword">new</span> Object[maxN + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pq.length; i++) &#123;</span><br><span class="line">            pq[i] = -<span class="number">1</span>;</span><br><span class="line">            qp[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">greater</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (comparator == <span class="keyword">null</span>) <span class="keyword">return</span> keys[pq[i]].compareTo(keys[pq[j]]) &lt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> comparator.compare(keys[pq[i]], keys[pq[j]]) &lt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = pq[i];</span><br><span class="line">            pq[i] = pq[j];</span><br><span class="line">            pq[j] = temp;</span><br><span class="line">            qp[pq[i]] = i;</span><br><span class="line">            qp[pq[j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> qp[k] != -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="上浮和下沉"><a href="#上浮和下沉" class="headerlink" title="上浮和下沉"></a>上浮和下沉</h4><p>上浮和下沉操作与优先队列相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; greater(k, k / <span class="number">2</span>)) &#123;</span><br><span class="line">        exchange(k, k / <span class="number">2</span>);</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k * <span class="number">2</span> &gt;= N) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = k * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; N - <span class="number">1</span> &amp;&amp; greater(j + <span class="number">1</span>, j)) j++;</span><br><span class="line">        <span class="keyword">if</span> (!greater(j, k)) <span class="keyword">break</span>;</span><br><span class="line">        exchange(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="改变-change"><a href="#改变-change" class="headerlink" title="改变 change"></a>改变 change</h4><p>改变优先队列中索引的值。（注意<code>keys</code>中的数据位置并未改变）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> k, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!contains(k)) <span class="keyword">return</span>;</span><br><span class="line">    keys[k] = key;</span><br><span class="line">    swim(qp[k]);</span><br><span class="line">    sink(qp[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入-insert"><a href="#插入-insert" class="headerlink" title="插入 insert"></a>插入 insert</h4><p>插入数据的同时，要维护<code>qp[]</code>数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (contains(k)) change(k, key);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ++N;</span><br><span class="line">        pq[N] = k;</span><br><span class="line">        pq[k] = N;</span><br><span class="line">        keys[k] = key;</span><br><span class="line">        swim(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最小值-min"><a href="#最小值-min" class="headerlink" title="最小值 min"></a>最小值 min</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keys[pq[<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除最小值并返回索引（优先级最高）"><a href="#删除最小值并返回索引（优先级最高）" class="headerlink" title="删除最小值并返回索引（优先级最高）"></a>删除最小值并返回索引（优先级最高）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deletMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">int</span> min = pq[<span class="number">1</span>];</span><br><span class="line">    exchange(<span class="number">1</span>, N--);</span><br><span class="line">    sink(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> min== pq[N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    pq[N + <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">    qp[min] = -<span class="number">1</span>;</span><br><span class="line">    keys[min] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-delete"><a href="#删除-delete" class="headerlink" title="删除 delete"></a>删除 delete</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">delete</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!contains(k)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> index = qp[k];</span><br><span class="line">    Key del = keys[k];</span><br><span class="line">    exchange(index, N--);</span><br><span class="line">    swim(index);</span><br><span class="line">    sink(index);</span><br><span class="line">    pq[N + <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">    qp[k] = -<span class="number">1</span>;</span><br><span class="line">    keys[k] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> del;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码实现-1"><a href="#完整代码实现-1" class="headerlink" title="完整代码实现"></a>完整代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexPriorityQueue</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] pq;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] qp;</span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">private</span> Comparator&lt;? <span class="keyword">super</span> Key&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexPriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexPriorityQueue</span><span class="params">(<span class="keyword">int</span> maxN)</span> </span>&#123;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">        pq = <span class="keyword">new</span> <span class="keyword">int</span>[maxN + <span class="number">1</span>];</span><br><span class="line">        qp = <span class="keyword">new</span> <span class="keyword">int</span>[maxN + <span class="number">1</span>];</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Object[maxN + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qp.length; i++) qp[i] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexPriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> Key&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexPriorityQueue</span><span class="params">(<span class="keyword">int</span> maxN, Comparator&lt;? <span class="keyword">super</span> Key&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(maxN);</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setComparator</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> Key&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">greater</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator == <span class="keyword">null</span>) <span class="keyword">return</span> keys[pq[i]].compareTo(keys[pq[j]]) &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> comparator.compare(keys[pq[i]], keys[pq[j]]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = temp;</span><br><span class="line">        qp[pq[i]] = i;</span><br><span class="line">        qp[pq[j]] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> qp[k] != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; greater(k, k / <span class="number">2</span>)) &#123;</span><br><span class="line">            exchange(k, k / <span class="number">2</span>);</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k * <span class="number">2</span> &gt;= N) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = k * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; N - <span class="number">1</span> &amp;&amp; greater(j + <span class="number">1</span>, j)) j++;</span><br><span class="line">            <span class="keyword">if</span> (!greater(j, k)) <span class="keyword">break</span>;</span><br><span class="line">            exchange(k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> k, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!contains(k)) <span class="keyword">return</span>;</span><br><span class="line">        keys[k] = key;</span><br><span class="line">        swim(qp[k]);</span><br><span class="line">        sink(qp[k]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (contains(k)) change(k, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ++N;</span><br><span class="line">            pq[N] = k;</span><br><span class="line">            pq[k] = N;</span><br><span class="line">            keys[k] = key;</span><br><span class="line">            swim(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[pq[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deletMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">int</span> min = pq[<span class="number">1</span>];</span><br><span class="line">        exchange(<span class="number">1</span>, N--);</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> min == pq[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        pq[N + <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        qp[min] = -<span class="number">1</span>;</span><br><span class="line">        keys[min] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">delete</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!contains(k)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> index = qp[k];</span><br><span class="line">        Key del = keys[k];</span><br><span class="line">        exchange(index, N--);</span><br><span class="line">        swim(index);</span><br><span class="line">        sink(index);</span><br><span class="line">        pq[N + <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        qp[k] = -<span class="number">1</span>;</span><br><span class="line">        keys[k] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> del;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IndexPQIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexPQIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> IndexPriorityQueue&lt;Key&gt; copy;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IndexPQIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            copy = <span class="keyword">new</span> IndexPriorityQueue&lt;&gt;(pq.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">                copy.insert(pq[i], keys[pq[i]]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !copy.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNext()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">return</span> copy.deletMin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础排序算法涉及到&lt;strong&gt;选择（冒泡）排序、插入排序、希尔排序、归并排序、快速排序、堆排序、优先队列&lt;/strong&gt;，这几种算法分别拥有不同的特点及实现，下面就简单介绍一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/tags/Algorithm/"/>
    
      <category term="Java" scheme="http://yif-hong.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>当我们谈论Java构造器时，我们在讨论什么？</title>
    <link href="http://yif-hong.github.io/2018/09/19/java-constructor/"/>
    <id>http://yif-hong.github.io/2018/09/19/java-constructor/</id>
    <published>2018-09-19T07:16:00.000Z</published>
    <updated>2020-09-12T08:12:15.280Z</updated>
    
    <content type="html"><![CDATA[<p>构造器是用来做什么的？当然是用来构造对象的！但是构造对象的过程你了解吗？</p><a id="more"></a><h3 id="构造对象过程中的坑"><a href="#构造对象过程中的坑" class="headerlink" title="构造对象过程中的坑"></a>构造对象过程中的坑</h3><p>请阅读以下代码，并模拟其输出的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> field = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father constructor before draw&quot;</span>);</span><br><span class="line">        draw();</span><br><span class="line">        System.out.println(<span class="string">&quot;Father constructor after draw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father c = <span class="keyword">new</span> Father();</span><br><span class="line">        c.draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father draw:&quot;</span> + field);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Output:~</span><br><span class="line">Father constructor before draw</span><br><span class="line">Father draw:200</span><br><span class="line">Father constructor after draw</span><br><span class="line">Father draw:200</span><br></pre></td></tr></table></figure><p>程序很正常的输出了两次200，然而当我们用一个子类去继承时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Child c = <span class="keyword">new</span> Child();</span><br><span class="line">        c.draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child draw:&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果让人意外！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Output:~</span><br><span class="line">Father constructor before draw</span><br><span class="line">Child draw:0</span><br><span class="line">Father constructor after draw</span><br><span class="line">Child draw:100</span><br></pre></td></tr></table></figure><p>这里涉及到继承和多态，当我们在构造对象的时候，消息的顺序一般是从自身向父类发送，逐层压入栈，然后顺序出栈构造（栈只是顺序，并不代表真正执行的结构）。</p><p><strong>父Static域 -&gt; 子Static域 -&gt; 父构造器涉及的域 -&gt; 父构造器 -&gt; 子构造器涉及的域 -&gt; 子构造器 ……</strong></p><p>而如果构造对象时，父类执行了一些（可能会）被子类重写的方法，则会出现上述不可预知的错误。原因在于，当我们执行到“父构造器”时，此时调用了<code>draw()</code>方法，由于我们对象时Child类型的，编译器则会根据多态（运行时绑定）寻找到被子类重写（Override）的方法，但是此时还未初始化子类的<code>value</code>域，故而输出错误的值。</p><p>好在此时编译器为我们赋予了类私有域一个默认值（0、null），否则我们的程序就要空指针了！</p><p>所以，在构造对象（构造器）时，<strong>尽量不要调用非final的方法（private方法是隐式的final方法）</strong>，否则会出现不可预知的问题，导致对象构建不完全。</p><p>当然，构造器还有一些其他的特性，比如<strong>被<code>private</code>修饰</strong>时，若无其他的构造器，则<strong>无法构建对象</strong>，自然也<strong>无法被继承</strong>。这里就不一一展开了，有兴趣的朋友请自行阅读《Thinking In Java》。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;构造器是用来做什么的？当然是用来构造对象的！但是构造对象的过程你了解吗？&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yif-hong.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yif-hong.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Volatile关键字解析</title>
    <link href="http://yif-hong.github.io/2018/09/11/Volatile/"/>
    <id>http://yif-hong.github.io/2018/09/11/Volatile/</id>
    <published>2018-09-11T09:47:09.000Z</published>
    <updated>2020-09-12T08:12:15.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考来源 <a href="http://www.cnblogs.com/dolphin0520/p/3920373.html">海子的博客</a></p></blockquote><p>volatile在Java 5之前一直是个备受争议的关键字，直到Java 5之后才焕发新机。虽然volatile的含义如此简洁，但是深入理解它则需要了解Java的内存模型。</p><a id="more"></a><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>在计算机中，执行程序时每条指令都是最终在CPU执行的，而指令在执行过程中，必然会和数据的读取和写入相关。由于程序运行时的临时数据是储存在主内存（RAM物理内存）中的，CPU的执行速度很快，而从内存中读取和写入相对CPU速度慢的多，于是CPU就有自己的存储结构——高速缓存。</p><blockquote><p>CPU一般的结构由控制单元、执行单元、存储单元组成。</p></blockquote><p><img src="http://www.elecfans.com/uploads/allimg/170526/2474217-1F526110253129.jpg" alt="CPU结构"></p><p>也就是说，在程序运行的过程中，CPU运算所需的数据需要从主存中复制一份到高速缓存中，然后通过读取-计算-写入，CPU完成计算写入后再将数据刷新到主存中。举个例子：</p><p><code>int i = i + 1;</code></p><p>当线程执行这段代码时，会先从主存中读取i的值，复制一份到高速缓存中，然后CPU执行对i+1的操作，再将数据写入高速缓存，最后将高速缓存中的i的值刷新到主存中。</p><p>在这个过程中，如果是单线程执行是没有问题的，但是在多线程中，会出现 <strong>缓存不一致</strong> 的问题。</p><h3 id="缓存不一致"><a href="#缓存不一致" class="headerlink" title="缓存不一致"></a>缓存不一致</h3><p>在多核心CPU中，每个线程独立运行于自己的CPU中，因此线程都会有属于自己的高速缓存。对于单核CPU而言，也会有这个问题，通过线程调度执行产生。这边以多核CPU为例：</p><p><code>int i = i + 1;</code></p><p>比如有2个线程同时执行这段代码，初始值为0，希望结果是i=2。大多数情况下是OK的，但是可能也会出现这种情况：初始时，两个线程分别将i的值从主存读取复制到各自的高速缓存中，然后线程1进行+1操作，i为1写入高速缓存并刷新内存，此时线程2的高速缓存仍然是0，进行+1操作后，i为1同样写入高速缓存并刷新内存。出现了最终结果是1而不是2的问题。</p><blockquote><p>通常这样多个线程访问的变量被称为共享变量。</p></blockquote><p>为了解决缓存不一致的问题，一般有以下两个方法：</p><ol><li>通过在总线加LOCK#锁。</li><li>通过缓存一致性协议。</li></ol><ul><li>以上都是在硬件层面解决问题。</li></ul><p>早期是通过在总线加LOCK#锁解决缓存不一致的问题。因为CPU和外部的通信是通过总线进行的，于是加锁则能保证同步一致，阻塞了其他CPU对部件通信（访问内存），虽然可以解决，但是效率太低了，因为访问其他部件的操作相对CPU的执行速度而言效率太低。于是就出现了缓存一致性协议。</p><blockquote><p><strong>缓存一致性协议</strong>：最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。<br>它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为 <strong>无效状态</strong> ，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p></blockquote><p><img src="http://pevzgedd6.bkt.clouddn.com/212219343783699.jpg" alt="缓存一致性协议"></p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><blockquote><p>并发编程中，经常要解决以下问题：原子性问题、可见性问题、有序性问题。</p></blockquote><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul><li>原子性是指一个操作或多个操作，要么全部执行并且不会被打断，要么不执行。</li></ul><p>反应这个概念最简单的模型就是“转账取款”的问题。</p><p>如果反映到并发编程中，以java举例，<code>i = 999;</code>，i是int为32位，赋值过程中，前16位写入后，中断，此时另一个线程读取i，则值会错乱。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ul><li>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得见修改后的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread 1</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;    <span class="comment">//语句1</span></span><br><span class="line">i = <span class="number">10</span>;       <span class="comment">//语句2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//thread 2</span></span><br><span class="line"><span class="keyword">int</span> j = i;</span><br></pre></td></tr></table></figure><p>假若线程1是CPU1，线程2是CPU2，当线程1执行到语句2时，此时CPU1高速缓存变为10，但是未刷新到主存中。则此时线程2执行，读取主存中的i仍然是0，使得j也变为0，出错。</p><p>可见性问题是在线程1修改变量后，线程2没有立刻看到线程1中的值。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><ul><li>有序性是指程序执行的顺序按照代码的先后顺序执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;   <span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;   <span class="comment">//语句2</span></span><br><span class="line">i = i + <span class="number">1</span>;   <span class="comment">//语句3</span></span><br><span class="line">j = j + i;   <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure><p>按照正常的程序执行顺序，应该是1234顺序执行语句指令，但是在JVM中，会对指令优化处理，发生 <strong>指令重排</strong> ，顺序可能变为2134。</p><p>虽然指令重排会使程序执行顺序发生变化，但是还是会有依赖顺序，不会出现语句4在语句3(或语句2）之前执行。因为在执行语句时，类似拓扑排序，会检查调用到的其他参数，保证其他参数执行完毕返回结果后，才会执行此语句。</p><p>对于单线程而言，不会产生问题。但是对于多线程，则会出现问题。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread1</span></span><br><span class="line">Context context = getContext(); <span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">boolean</span> init = <span class="keyword">true</span>;            <span class="comment">//语句2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//thread2</span></span><br><span class="line"><span class="keyword">while</span>(!init) sleep();           <span class="comment">//语句3</span></span><br><span class="line">doSomething(context);           <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure><p>此时语句1语句2无依赖关系，则线程1中，很有可能会语句2先于语句1执行，此时线程2则会错误的认为context已经初始化ok，然后跳出循环执行语句4,实际context要在语句2才执行，进而导致异常。</p><p>因此可以看出，JVM指令重排对于单线程没有影响，但是多线程会导致可能出现错误。</p><blockquote><p>在并发编程中,若未保证以上三原则中的任何一个，都会产生不可预知的问题。</p></blockquote><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>在JVM虚拟机中，试图定义一种Java内存模型(Java Memory Model,JMM)，以此解决跨硬件和不同操作系统上的内存访问差异，完善跨平台性。其中，JMM主要定义了程序中访问变量的访问规则，即程序的执行顺序（有序性）。</p><p>但是，为了更好的性能，JMM并没有禁止指令重排,也没有限制CPU在指令的处理上使用寄存器和高速缓存。所以，JMM也会产生缓存一致性问题和指令重排的问题。</p><p>JMM规定所有变量都是存在于主存中（物理内存），所有线程都有自己的工作内存（类似CPU的高速缓存），线程对变量的操作必须在工作内存中完成，无法直接对主存操作，并且不能访问其他线程的工作内存。</p><p>例如<code>i = 10</code>，规定线程从主存中复制i到自己的工作内存中，然后在工作内存中赋值i的值为10，最后再刷新主存中的i的值。注意，线程不是直接操作主存中的变量。</p><h3 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h3><ul><li>在Java中，对基本数据类型的变量进行简单的读取和赋值是原子性的，不可被中断的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>;      <span class="comment">//语句1</span></span><br><span class="line">y = x;      <span class="comment">//语句2</span></span><br><span class="line">x++;        <span class="comment">//语句3</span></span><br><span class="line">x = x + <span class="number">1</span>;  <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure><p>以上4个语句，只有语句1变量赋值是原子操作。语句2涉及读取x、赋值y的两步操作。虽然单步是原子操作，但是两步合起来就不是了。同样语句3和语句4都是读取x、执行x+1、赋值给x，三步。</p><blockquote><p>不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p></blockquote><ul><li>对于其他代码块的原子性问题，可以通过<code>synchronized</code>和<code>Lock</code>来锁块。</li></ul><h3 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h3><p>对于可见性，Java使用volatile来保证。也就是本章的主题。</p><p>当一个共享变量被volatile修饰时，会保证在被修改的时候立刻存入主存，当有其他线程需要读取时，会重新到主存中读取新的值。</p><p>而未修饰的共享变量则无法保证可见性，因为写入主存的时间不固定。</p><p>另外，通过<code>synchronized</code>和<code>Lock</code>也可以保证可见性，因为它们可以保证同一时刻只有一个线程操作变量（对象），执行代码直至释放锁。在释放锁之前，会将对变量的修改写入主存中。</p><h3 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h3><p>之前提到过JVM的指令重排问题。这里可以用volatile保证一定的有序性（原因见下）。当然，<code>synchronized</code>和<code>Lock</code>一样可以，原因不再赘述。</p><blockquote><p>Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p></blockquote><h3 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h3><blockquote><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul><footer><strong>《深入理解Java虚拟机》</strong></footer></blockquote><ol><li>单线程内程序的运行结果和代码的书写顺序一致。这里并不是指程序执行过程一致，因为JVM有重排机制，但是输出的结果是肯定一致的。</li><li>也就是说，不论单线程还是多线程，都会等待线程锁释放后再执行获取锁的操作。</li><li>volatile的关键特性，简单的说就是，如果一个线程先去写一个变量，另一个线程进行读取，那么volatile保证写入一定在读取之前。</li><li>happens-before具有传递性。</li></ol><p>后面4条比较简单，就不赘述了。</p><h2 id="剖析volatile关键字"><a href="#剖析volatile关键字" class="headerlink" title="剖析volatile关键字"></a>剖析volatile关键字</h2><h3 id="两层语义"><a href="#两层语义" class="headerlink" title="两层语义"></a>两层语义</h3><p>一旦一个共享变量被volatile修饰后，则具备以下两个语义：</p><ol><li>保证了不同线程对这个变量操作的可见性，即一个线程修改了变量的值，在对另一个线程是立即可见的，读取变量时会重新进入主存中读取。</li><li>禁止了指令重排。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread 1</span></span><br><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop) doSomething();</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread2</span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>这是一个常见的带有中断的多线程任务流程。按照代码执行，线程2一定会使线程1中断吗？</p><p>不一定。由于之前所说的JMM规则（可见性）导致的这一问题。这种bug概率虽极低，但是一旦出现，不好排查且后果严重，会造成无限循环、死锁等。</p><p>具体描述是，线程1有自己的工作线程，读取stop值后复制到自己的工作内存中，此时执行工作。如果此时线程2读取主存的stop值，然后在自己的工作内存中改变stop，在写入主存之前，被中断或进行其他工作。此时线程1则会无法知道stop已经被改变，进而引发问题。</p><p>但是如果被volatile修饰后，则：</p><ol><li>强制修改变量的值立刻写入主存。</li><li>当线程2进行修改时，会导致线程1工作内存的stop缓存无效（映射到硬件层的话，就是CPU的L1或L2缓存中的对应缓存行无效）。</li><li>由于线程1中stop缓存无效，则线程1会去主存中重新读取stop的值。程序运行正常。</li></ol><h3 id="保证原子性"><a href="#保证原子性" class="headerlink" title="保证原子性"></a>保证原子性</h3><ul><li>volatile无法保证对变量的任何操作的原子性。</li></ul><p>当然，基于JMM，原子操作的原子性肯定是可以保证的。</p><p>此时可以采用<code>synchronized</code>和<code>Lock</code>来解决代码块的原子性问题。对于基础数据结构，Java还提供了原子数据结构（比如<code>AtomicInteger</code>）,对自增、自减、加法、减法进行封装，保证这些操作的原子性。</p><blockquote><p><code>AtomicInteger</code>利用CAS(Compare And Swap)来实现原子操作的，CAS实际是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG是原子操作。</p></blockquote><h3 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h3><ul><li>volatile禁止指令重排，所以一定程度上可以保证有序性。</li></ul><p>这里有两层含义：</p><ol><li>当程序执行到volatile修饰的变量（读写）时，在其之前的操作保证一定完成，且结果对后续程序可见（写入主存），在其后面的语句还未执行。</li><li>JVM将指令优化时，无法将volatile修饰的变量进行重排（无法改变变量执行时的顺序）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread1</span></span><br><span class="line">Context context = getContext(); <span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> init = <span class="keyword">true</span>;   <span class="comment">//语句2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//thread2</span></span><br><span class="line"><span class="keyword">while</span>(!init) sleep();           <span class="comment">//语句3</span></span><br><span class="line">doSomething(context);           <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure><p>比如之前的代码，若volatile对init修饰，则不会出现语句2在语句1之前执行，程序正确执行。</p><h3 id="原理和实现机制"><a href="#原理和实现机制" class="headerlink" title="原理和实现机制"></a>原理和实现机制</h3><blockquote><p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p><footer><strong>《深入理解Java虚拟机》</strong></footer></blockquote><p>lock前缀指令相当于内存屏障（内存栅栏），提供3个功能：</p><ol><li>执行指令时，前面的操作已经全部完成。</li><li>强制缓存修改参数立刻写入主存。</li><li>如果是写操作，会导致其他CPU中对于的缓存无效（可见性）。</li></ol><h2 id="volatile使用场景"><a href="#volatile使用场景" class="headerlink" title="volatile使用场景"></a>volatile使用场景</h2><p><code>synchronized</code>可以防止多个线程执行一段代码块，但是影响程序执行效率，而volatile在某些情况下的性能要优于<code>synchronized</code>。但是之前说过，volatile无法保证操作的原子性，所以无法替代<code>synchronized</code>。一般来说，使用volatile必须具备以下条件：</p><ol><li>对变量的写操作不依赖当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li></ol><p>以上表明，可以被写入volatile变量的有效值是独立于程序的任何状态，包括变量的当前状态。</p><p>其实主要上述是为了保证操作是原子操作，否则在并发时无法得到正确执行。</p><p>以下举例常用场景：</p><figure class="highlight java"><figcaption><span>中断线程任务</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread 1</span></span><br><span class="line"><span class="keyword">while</span>(!flag) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.flag = flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个之前讨论过了，就不赘述了。</p><figure class="highlight java"><figcaption><span>double-check</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查源自Java的Singleton单例模式(同步延迟加载)。关于单例模式，有空再总结一下。</p><hr><p><em>参考文献：《Java编程思想》《深入理解Java虚拟机》</em></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文参考来源 &lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3920373.html&quot;&gt;海子的博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;volatile在Java 5之前一直是个备受争议的关键字，直到Java 5之后才焕发新机。虽然volatile的含义如此简洁，但是深入理解它则需要了解Java的内存模型。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yif-hong.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yif-hong.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="http://yif-hong.github.io/tags/JVM/"/>
    
      <category term="Concurrency" scheme="http://yif-hong.github.io/tags/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>图论——最短路径</title>
    <link href="http://yif-hong.github.io/2018/09/02/Graph-SP/"/>
    <id>http://yif-hong.github.io/2018/09/02/Graph-SP/</id>
    <published>2018-09-02T12:16:23.000Z</published>
    <updated>2020-09-12T08:12:15.278Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>阅读此篇之前，需要了解<a href="http://yifhong.com/2018/09/01/Graph-general/">图论的基础知识</a>、<a href="http://yifhong.com/2018/09/02/Graph-Topological">拓扑排序</a>、<a href="http://yifhong.com/2018/09/02/Graph-MST">最小生成树</a>。</em></p></blockquote><p>最短路径的最直观应用就是在地图导航中，路口对应顶点，公路对应边，如果是单行道对应有向边，公路长短对应权重。抽象模型来看，就是<strong>从一个顶点到另一个顶点的最小成本路径</strong>——单点最短路径。</p><a id="more"></a><blockquote><p>问题模型定义：</p><ul><li>边是有向的。（区别于最小生成树）</li><li>边的权重不一定表示距离，更合适的应称为成本。（可以表示很多意义）</li><li>边的权重为负会比较复杂，我们最后讨论为负的情况。</li><li>最短路径都是简单路径。（不含有环）</li><li>最短路径不唯一。</li><li>可能存在自环或平行边。（分析时不考虑，算法可以处理）</li></ul></blockquote><p>最短路径表示的是任意<strong>顶点v到起点s</strong>的权重都是最短路径，而最小生成树是顶点v到树的权重最小，两者要分清楚。</p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>处理最短路径问题，需要加权有向边构成的加权有向图作为数据结构基础。</p><h3 id="加权有向边"><a href="#加权有向边" class="headerlink" title="加权有向边"></a>加权有向边</h3><p>与<code>Edge</code>相比，把边的两个顶点重新明确为<code>from()</code>到<code>to()</code>，用以表示边的方向。</p><figure class="highlight java"><figcaption><span>DirectedEdge 加权有向边</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_4/DirectedEdge.java">DirectedEdge.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedEdge</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">DirectedEdge</span>&gt; </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> v;            <span class="comment">//边的起点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> w;            <span class="comment">//边的终点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">from</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">to</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加权有向图"><a href="#加权有向图" class="headerlink" title="加权有向图"></a>加权有向图</h3><p>与加权无向图<code>EdgeWeightedGraph</code>相比，将图中的边替换为加权有向边<code>DirectedEdge</code>，再稍作修改<code>addEdge()</code>即可。</p><figure class="highlight java"><figcaption><span>EdgeWeightedDigraph 加权有向图</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_4/EdgeWeightedDigraph.java">EdgeWeightedDigraph.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeWeightedDigraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V;                <span class="comment">//顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;                      <span class="comment">//边</span></span><br><span class="line">    <span class="keyword">private</span> Bag&lt;DirectedEdge&gt;[] adj;    <span class="comment">//邻接表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedDigraph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        E = <span class="number">0</span>;</span><br><span class="line">        adj = (Bag&lt;DirectedEdge&gt;[]) <span class="keyword">new</span> Bag[V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++)</span><br><span class="line">            adj[v] = <span class="keyword">new</span> Bag&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(DirectedEdge edge)</span> </span>&#123;</span><br><span class="line">        adj[edge.from()].add(edge);</span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Bag&lt;DirectedEdge&gt; bag = <span class="keyword">new</span> Bag&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++)</span><br><span class="line">            <span class="keyword">for</span> (DirectedEdge edge : adj[v])</span><br><span class="line">                bag.add(edge);</span><br><span class="line">        <span class="keyword">return</span> bag;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路径操作原理"><a href="#最短路径操作原理" class="headerlink" title="最短路径操作原理"></a>最短路径操作原理</h2><p>最短路径需要的数据结构很简单：</p><ul><li>最短路径树的边<code>edgeTo[]</code>。</li><li>到达起点的距离<code>distTo[]</code>。</li></ul><h3 id="松弛"><a href="#松弛" class="headerlink" title="松弛"></a>松弛</h3><blockquote><p>与最小生成树的Prim即时算法类似，在每次添加边的时候，会对原有的路径进行权重对比，如果出现更小的路径，则替换当前路径。这个操作就是松弛</p></blockquote><figure class="highlight java"><figcaption><span>relax(edge) 对边的放松</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedEdge edge)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = edge.from(), w = edge.to();</span><br><span class="line">    <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + edge.weight()) &#123;</span><br><span class="line">        distTo[w] = distTo[v] + edge.weight();</span><br><span class="line">        edgeTo[w] = edge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际的实现中，实现松弛会放松<code>relax()</code>一个给定顶点指出的所有边。</p><figure class="highlight java"><figcaption><span>relax(v) 对顶点的放松</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (DirectedEdge edge : G.adj(v)) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = edge.to();</span><br><span class="line">        <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + edge.weight()) &#123;</span><br><span class="line">            distTo[w] = distTo[v] + edge.weight();</span><br><span class="line">            edgeTo[w] = edge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><blockquote><p><strong>边的权重不能为负！</strong></p></blockquote><p>对于实现算法，我们仍需要<code>IndexMinPQ&lt;T&gt;</code>来保存即将被放松的顶点。算法的实现非常相似于Prim算法的即时实现，仅仅是替换为加权有向图来表示。</p><p>证明请查看<a href="/2018/09/02/Graph-MST">Prim算法</a>。</p><figure class="highlight java"><figcaption><span>DijkstraSP Dijkstra算法</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_4/DijkstraSP.java">DijkstraSP.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraSP</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;</span><br><span class="line">    <span class="keyword">private</span> IndexMinPQ&lt;Double&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DijkstraSP</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        ···</span><br><span class="line">        distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">        pq.insert(s, distTo[s]);</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())</span><br><span class="line">            relax(G, pq.delMin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= distTo.length) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;vertex is illegal!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge edge : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = edge.to();</span><br><span class="line">            <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + edge.weight()) &#123;</span><br><span class="line">                distTo[w] = distTo[v] + edge.weight();</span><br><span class="line">                edgeTo[w] = edge;</span><br><span class="line">                <span class="keyword">if</span> (pq.contains(w)) pq.changeKey(w, distTo[w]);</span><br><span class="line">                <span class="keyword">else</span> pq.insert(w, distTo[w]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul><li>空间：V</li><li>时间：ElogV</li></ul><h4 id="给定两点之间的最短路径"><a href="#给定两点之间的最短路径" class="headerlink" title="给定两点之间的最短路径"></a>给定两点之间的最短路径</h4><p>直接用Dijkstra算法就可以，s-&gt;t，从起点s开始relax，直到优先队列取到t为止即可。</p><h4 id="任意顶点对之间的最短路径"><a href="#任意顶点对之间的最短路径" class="headerlink" title="任意顶点对之间的最短路径"></a>任意顶点对之间的最短路径</h4><p>可以将每个元素都作为顶点构造<code>DijkstraSP</code>对象。</p><p>性能：时间和空间均与 EVlogV 成正比。</p><p>点击查看<a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_4/DijkstraAllPairsSP.java">算法实现</a>。</p><h3 id="无环加权有向图中的最短路径算法"><a href="#无环加权有向图中的最短路径算法" class="headerlink" title="无环加权有向图中的最短路径算法"></a>无环加权有向图中的最短路径算法</h3><blockquote><p><strong>通过拓扑排序来构成数据结构，按照拓扑排序的顺序依次放松各个顶点。</strong></p></blockquote><h4 id="算法优点"><a href="#算法优点" class="headerlink" title="算法优点"></a>算法优点</h4><ul><li>能够在线性时间内处理单点最短路径问题。</li><li>能够处理负权重边的情况。</li><li>能够处理最长路径问题。</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>这里需要<code>Topological</code>拓扑排序接受<code>EdgeWeightedDigraph</code>和<code>DirectedEdge</code>为参数，检测有向环以及构建数据结构。<a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_4/EdgeWeightedDirectedCycle.java">寻找有向环的算法实现</a></p><p><code>AcyclicSP</code>由Dijkstra算法改编而来，仅仅修改了初始化时放松顶点的顺序即可。</p><figure class="highlight java"><figcaption><span>AcyclicSP 无环加权有向图的最短路径算法</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_4/AcyclicSP.java">AcyclicSP.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcyclicSP</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AcyclicSP</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        ···</span><br><span class="line">        Topological top = <span class="keyword">new</span> Topological(G);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : top.order())</span><br><span class="line">            relax(G, v);</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h4><ul><li>性能：</li><li>时间：E+V，线性</li></ul><h4 id="无环加权有向图中的最长路径算法"><a href="#无环加权有向图中的最长路径算法" class="headerlink" title="无环加权有向图中的最长路径算法"></a>无环加权有向图中的最长路径算法</h4><p>通过最短路径改编即可，<a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_4/AcyclicLP.java">算法实现AcyclicLP</a>：</p><ol><li>将所有边<code>clone()</code>得到副本，再将副本的权重取相反数，即可。</li><li>将<code>distTo[]</code>初始赋值变为<code>Double.NEGATIVE_INFINITY</code>，并改变<code>relax()</code>中判断不等式的方向，即可。</li></ol><h4 id="优先级限制下的并行任务调度"><a href="#优先级限制下的并行任务调度" class="headerlink" title="优先级限制下的并行任务调度"></a>优先级限制下的并行任务调度</h4><p>拓扑排序相对来说只是单个处理器执行问题处理，而并行任务调度则是多个处理器同时处理问题。</p><blockquote><p><strong>这个问题其实是求解最长路径的问题。</strong>（木桶短板效应）</p><ul><li><strong>性能：线性</strong></li></ul></blockquote><h5 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h5><p>解决此类问题的算法称为关键路径，实现步骤如下：</p><ol><li>创建无环加权有向图。</li><li>所有任务的起始为起点s，指向每个先行任务的开始，终点为t，每个最后执行任务的结束指向t。</li><li>任务作为边，边的权重为每个任务的花费时间，优先级<code>v -&gt; w</code>为任务的结束点指向下一个任务的起始点。</li><li>每个任务预计的花费时间为任务自身的权重加上任务起点距离起点s的权重。这样就转化为最长路径的问题。</li></ol><figure class="highlight java"><figcaption><span>CPM 关键路径的一种实现</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_4/CPM.java">CPM.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CPM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = StdIn.readInt();</span><br><span class="line">        StdIn.readLine();</span><br><span class="line">        EdgeWeightedDigraph G = <span class="keyword">new</span> EdgeWeightedDigraph(<span class="number">2</span> * N + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> s = N * <span class="number">2</span>, t = N * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//s起点，t终点，0~2N所有顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            String[] a = StdIn.readLine().split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">            <span class="keyword">double</span> duration = Double.parseDouble(a[<span class="number">0</span>]);</span><br><span class="line">            G.addEdge(<span class="keyword">new</span> DirectedEdge(i, i + N, duration));</span><br><span class="line">            G.addEdge(<span class="keyword">new</span> DirectedEdge(s, i, <span class="number">0.0</span>));</span><br><span class="line">            G.addEdge(<span class="keyword">new</span> DirectedEdge(i + N, t, <span class="number">0.0</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> successor = Integer.parseInt(a[j]);</span><br><span class="line">                G.addEdge(<span class="keyword">new</span> DirectedEdge(i + N, successor, <span class="number">0.0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        AcyclicLP lp = <span class="keyword">new</span> AcyclicLP(G, s);</span><br><span class="line">        System.out.println(<span class="string">&quot;Start times:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d: %5.1f\n&quot;</span>, i, lp.distTo(i));</span><br><span class="line">        System.out.printf(<span class="string">&quot;Finish time: %5.1f\n&quot;</span>, lp.distTo(t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相对最后期限限制下的并行任务调度"><a href="#相对最后期限限制下的并行任务调度" class="headerlink" title="相对最后期限限制下的并行任务调度"></a>相对最后期限限制下的并行任务调度</h4><blockquote><p><strong>其实这是一个最短路径问题。</strong></p></blockquote><h3 id="一般加权有向图中的最短路径"><a href="#一般加权有向图中的最短路径" class="headerlink" title="一般加权有向图中的最短路径"></a>一般加权有向图中的最短路径</h3><p>此时我们需要探讨负权重边带来的情况。</p><blockquote><p>负权重环，指一个总权重之和为负的环。</p></blockquote><p><strong>一旦出现负权重环，则不存在最短路径。</strong></p><blockquote><p>因为可以在负权重环中无限循环从而产生任意小的最短路径。因此我们需要s到v的有向路径上的任意顶点都不存在于任何负权重环中。</p></blockquote><p>于是实现算法需要解决以下问题：</p><ul><li>负权重环的检测。</li><li>负权重环不可达时的最短路径问题。</li></ul><h4 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h4><h5 id="检测负权重环"><a href="#检测负权重环" class="headerlink" title="检测负权重环"></a>检测负权重环</h5><p>类似于之前<a href="/2018/09/02/Graph-Topological">拓扑排序</a>中寻找有向环的检测，我们这里也用一个<code>onQ[]</code>来记录顶点是否在放松过的栈上，防止重复加入队列。</p><figure class="highlight java"><figcaption><span>relax(G,v) Bellman-Ford中检测负权重环</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (DirectedEdge edge : G.adj(v)) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = edge.to();</span><br><span class="line">        <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + edge.weight()) &#123;</span><br><span class="line">            distTo[w] = distTo[v] + edge.weight();</span><br><span class="line">            edgeTo[w] = edge;</span><br><span class="line">            <span class="keyword">if</span> (!onQ[w]) &#123;</span><br><span class="line">                queue.enqueue(w);</span><br><span class="line">                onQ[w] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cost++ % G.V() == <span class="number">0</span>)</span><br><span class="line">            findNegativeCycle();<span class="comment">//周期性寻找负权重环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="寻找负权重环"><a href="#寻找负权重环" class="headerlink" title="寻找负权重环"></a>寻找负权重环</h5><p>这里采用<code>EdgeWeightedDirectedCycle</code>(最短路径中拓扑排序)来检测加权有向环。</p><figure class="highlight java"><figcaption><span>findNegativeCycle() 寻找负权重环</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findNegativeCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V = edgeTo.length;</span><br><span class="line">    EdgeWeightedDigraph spt;</span><br><span class="line">    spt = <span class="keyword">new</span> EdgeWeightedDigraph(V);</span><br><span class="line">    <span class="keyword">for</span> (DirectedEdge edge : edgeTo)</span><br><span class="line">        <span class="keyword">if</span> (edge != <span class="keyword">null</span>)</span><br><span class="line">            spt.addEdge(edge);</span><br><span class="line">    EdgeWeightedDirectedCycle finder = <span class="keyword">new</span> EdgeWeightedDirectedCycle(spt);</span><br><span class="line">    cycle = finder.cycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight java"><figcaption><span>BellmanFordSP 基于队列的Bellman-Ford算法</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_4/BellmanFordSP.java">BellmanFordSP.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BellmanFordSP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;                <span class="comment">//从起点到某个顶点的路径长度</span></span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;          <span class="comment">//从起点到某个顶点的最后一条边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] onQ;                  <span class="comment">//该顶点是否存在于队列中</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;           <span class="comment">//正在被放松的顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cost;                       <span class="comment">//relax() 的调用次数</span></span><br><span class="line">    <span class="keyword">private</span> Iterable&lt;DirectedEdge&gt; cycle;   <span class="comment">//edgeTo[] 中是否还有负权重环</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BellmanFordSP</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> DirectedEdge[G.V()];</span><br><span class="line">        onQ = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        queue = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">            distTo[v] = Double.POSITIVE_INFINITY;</span><br><span class="line">        distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">        onQ[s] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; !hasNegativeCycle()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = queue.dequeue();</span><br><span class="line">            onQ[v] = <span class="keyword">false</span>;</span><br><span class="line">            relax(G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findNegativeCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">negativeCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNegativeCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="性能-2"><a href="#性能-2" class="headerlink" title="性能"></a>性能</h5><ul><li>空间：V</li><li>时间：EV（放松E条边，重复V轮）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;阅读此篇之前，需要了解&lt;a href=&quot;http://yifhong.com/2018/09/01/Graph-general/&quot;&gt;图论的基础知识&lt;/a&gt;、&lt;a href=&quot;http://yifhong.com/2018/09/02/Graph-Topological&quot;&gt;拓扑排序&lt;/a&gt;、&lt;a href=&quot;http://yifhong.com/2018/09/02/Graph-MST&quot;&gt;最小生成树&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最短路径的最直观应用就是在地图导航中，路口对应顶点，公路对应边，如果是单行道对应有向边，公路长短对应权重。抽象模型来看，就是&lt;strong&gt;从一个顶点到另一个顶点的最小成本路径&lt;/strong&gt;——单点最短路径。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/tags/Algorithm/"/>
    
      <category term="Java" scheme="http://yif-hong.github.io/tags/Java/"/>
    
      <category term="Graph" scheme="http://yif-hong.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>图论——最小生成树</title>
    <link href="http://yif-hong.github.io/2018/09/02/Graph-MST/"/>
    <id>http://yif-hong.github.io/2018/09/02/Graph-MST/</id>
    <published>2018-09-02T10:10:21.000Z</published>
    <updated>2020-09-12T08:12:15.278Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>阅读此篇之前，需要了解<a href="http://yifhong.com/2018/09/01/Graph-general/">图论的基础知识</a>。</em></p></blockquote><p>最小生成树MST应用的领域十分广泛，它比普通的无向图（连通图）多了权重的属性，这就使最小生成树可以被用来评估成本最小化的问题。</p><a id="more"></a><blockquote><p>一些约定：</p><ul><li>只考虑连通图。（树是连通的）</li><li>边的权重不一定表示距离。（可以表示很多意义）</li><li>边的权重可能为0，也可能为负。</li><li>所有边的权重各不相同。（相同权重的边会导致出现不同的最小生成树，为了简化分析，故此约定。但算法的实现不影响相同权重的情况。）</li></ul></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>树的性质：</p><ul><li>连通树中任意两个顶点都会产生环。</li><li>删除任意一条边都会得到两个独立的树。</li></ul><h3 id="切分定理"><a href="#切分定理" class="headerlink" title="切分定理"></a>切分定理</h3><blockquote><p>切分是将图的所有顶点分为两个非空且互不重叠的集合。<br>横切边是指一条连接两个属于不同集合顶点的边。<br><strong>给定任意的切分，横切边中最小者必然属于最小生成树。</strong></p></blockquote><p>切分定理也可以理解为一种<strong>贪心算法</strong>。不断重复寻找最小的横切边从而生成最小生成树。</p><h2 id="加权无向图"><a href="#加权无向图" class="headerlink" title="加权无向图"></a>加权无向图</h2><p>为了可以处理权重，我们在无向图的基础上，加入带有权重的边<code>Edge</code>来生成加权无向图<code>EdgeWeightedGraph</code>。</p><h3 id="带有权重的边"><a href="#带有权重的边" class="headerlink" title="带有权重的边"></a>带有权重的边</h3><figure class="highlight java"><figcaption><span>Edge 带有权重的边</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_3/Edge.java">Edge.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> v;            <span class="comment">//顶点之一</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> w;            <span class="comment">//另一个顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> weight;    <span class="comment">//边的权重</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        <span class="keyword">this</span>.w = w;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">either</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">other</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vertex == v) <span class="keyword">return</span> w;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vertex == w) <span class="keyword">return</span> v;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Inconsistent edge&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Edge that)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.weight(), that.weight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现加权无向图"><a href="#实现加权无向图" class="headerlink" title="实现加权无向图"></a>实现加权无向图</h3><p>只需修改Graph中的<code>addEdge()</code>和邻接表<code>adj[]</code>即可。</p><figure class="highlight java"><figcaption><span>EdgeWeightedGraph 加权无向图</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_3/EdgeWeightedGraph.java">EdgeWeightedGraph.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeWeightedGraph</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">private</span> Bag&lt;Edge&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedGraph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        ···</span><br><span class="line">        adj = (Bag&lt;Edge&gt;[]) <span class="keyword">new</span> Bag[V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++)</span><br><span class="line">            adj[v] = <span class="keyword">new</span> Bag&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Edge edge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge.either();</span><br><span class="line">        <span class="keyword">int</span> w = edge.other(v);</span><br><span class="line">        adj[v].add(edge);</span><br><span class="line">        adj[w].add(edge);</span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Edge&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Bag&lt;Edge&gt; bag = <span class="keyword">new</span> Bag&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++)</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : adj[v])</span><br><span class="line">                <span class="keyword">if</span> (edge.other(v) &gt; v) bag.add(edge);<span class="comment">//防止重复添加</span></span><br><span class="line">        <span class="keyword">return</span> bag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><blockquote><p>Prim算法的每一步都会为一颗生长的树添加一条边。这条边是<strong>由树中的顶点，与不在树中的顶点且权重最小的边构成。</strong></p></blockquote><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>顶点。通过<code>marked[]</code>标记是否已访问。</li><li>边。用<code>Queue队列</code>或<code>edgeTo[]数组</code>保存边，其中<code>edgeTo[v]</code>为将v(不在树中)连接到树中的<code>Edge</code>对象。</li><li>横切边。通过使用优先队列<code>MinPQ&lt;Edge&gt;</code>来根据权重返回最小的边。</li></ul><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>这里<code>MinPQ&lt;T&gt;</code>只是一种优先队列，提供<code>deleteMin()</code>删除返回最小项，<code>insert(T item)</code>插入新的项。</p><h5 id="优先队列性能"><a href="#优先队列性能" class="headerlink" title="优先队列性能"></a>优先队列性能</h5><ul><li>空间：E</li><li>时间：logE</li></ul><h3 id="Prim延迟实现"><a href="#Prim延迟实现" class="headerlink" title="Prim延迟实现"></a>Prim延迟实现</h3><p>延迟实现，指的是优先队列添加边时，先不检查是否有效（有效指是否已被访问、是否新添加的边权重更小），而是在<code>deleteMin()</code>时，再检查边的有效性。</p><figure class="highlight java"><figcaption><span>LazyPrimMST Prim延迟算法</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_3/LazyPrimMST.java">LazyPrimMST.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyPrimMST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;   <span class="comment">//最小生成树的顶点</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Edge&gt; mst;    <span class="comment">//最小生成树的边</span></span><br><span class="line">    <span class="keyword">private</span> MinPQ&lt;Edge&gt; pq;     <span class="comment">//横切边（包括失效的边）,MinPQ为优先队列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyPrimMST</span><span class="params">(EdgeWeightedGraph G)</span> </span>&#123;</span><br><span class="line">        pq = <span class="keyword">new</span> MinPQ&lt;&gt;();</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        mst = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        visit(G, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            Edge e = pq.delMin();                   <span class="comment">//从pq中得到权重最小的边</span></span><br><span class="line">            <span class="keyword">int</span> v = e.either(), w = e.other(v);</span><br><span class="line">            <span class="keyword">if</span> (marked[v] &amp;&amp; marked[w]) <span class="keyword">continue</span>;   <span class="comment">//跳过失效的边</span></span><br><span class="line">            mst.enqueue(e);                         <span class="comment">//将边添加到树中</span></span><br><span class="line">            <span class="keyword">if</span> (!marked[v]) visit(G, v);            <span class="comment">//将顶点添加到树中</span></span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) visit(G, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(EdgeWeightedGraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//标记顶点v并将所有连接v和未被标记的边加入pq</span></span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge e : G.adj(v))</span><br><span class="line">            <span class="keyword">if</span> (!marked[e.other(v)]) pq.insert(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> weight = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge e : edges())</span><br><span class="line">            weight += e.weight();</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Prim延迟实现的性能："><a href="#Prim延迟实现的性能：" class="headerlink" title="Prim延迟实现的性能："></a>Prim延迟实现的性能：</h4><ul><li>空间：E（最多只能添加E条边）</li><li>时间：ElogE（对E条边进行删除插入操作）</li></ul><h3 id="Prim即时实现"><a href="#Prim即时实现" class="headerlink" title="Prim即时实现"></a>Prim即时实现</h3><blockquote><p>其实我们每次在保存优先队列时，更关注权重最小的新的边，这样可以使新顶点w与树的距离更小，从而形成最小生成树。</p></blockquote><p>与<code>LazyPrimMST</code>相比，将<code>marked[]</code>和<code>mst[]</code>替换为<code>distTo[]</code>和<code>edgeTo[]</code>。</p><ul><li>假设v不在树中，但是至少有一条边与树相连，将要添加。</li><li><code>distTo[v]</code>：表示v与树的最短边的权重。</li><li><code>edgeTo[v]</code>：表示v与树的最短边。</li><li>所有像v这类顶点都被保存在索引优先队列<code>IndexMinPQ&lt;T&gt;</code>中，索引v关联的值即最短边权重。</li></ul><blockquote><p>关于索引优先队列：使用索引<code>int</code>来对应值的一种优先队列.<br>性能：空间：V ，时间：logV</p></blockquote><figure class="highlight java"><figcaption><span>LazyPrimMST Prim延迟算法</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_3/LazyPrimMST.java">LazyPrimMST.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Edge[] edgeTo;          <span class="comment">//距离树最近的边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;        <span class="comment">//distTo[w]=edgTo[w].weight()</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;       <span class="comment">//如果v在树中，则为true。可以去除，用disTo[]是否等于Double.POSITIVE_INFINITY来判断</span></span><br><span class="line">    <span class="keyword">private</span> IndexMinPQ&lt;Double&gt; pq;  <span class="comment">//有效的横切边</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimMST</span><span class="params">(EdgeWeightedGraph G)</span> </span>&#123;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> Edge[G.V()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">            distTo[v] = Double.POSITIVE_INFINITY;<span class="comment">//无限大</span></span><br><span class="line">        pq = <span class="keyword">new</span> IndexMinPQ&lt;&gt;(G.V());</span><br><span class="line"></span><br><span class="line">        distTo[<span class="number">0</span>] = <span class="number">0.0</span>;</span><br><span class="line">        pq.insert(<span class="number">0</span>, <span class="number">0.0</span>);   <span class="comment">//用顶点0、权重0初始化pq</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())</span><br><span class="line">            visit(G, pq.delMin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(EdgeWeightedGraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将顶点v添加到树中，并更新数据</span></span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge e : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = e.other(v);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (marked[w]) <span class="keyword">continue</span>;    <span class="comment">//v-w失效</span></span><br><span class="line">            <span class="keyword">if</span> (e.weight() &lt; distTo[w]) &#123;</span><br><span class="line">                <span class="comment">//连接w和树的最佳边变为e，更新数据</span></span><br><span class="line">                edgeTo[w] = e;</span><br><span class="line">                distTo[w] = e.weight();</span><br><span class="line">                <span class="keyword">if</span> (pq.contains(w)) pq.changeKey(w, distTo[w]);</span><br><span class="line">                <span class="keyword">else</span> pq.insert(w, distTo[w]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Edge&gt; edges = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Edge anEdgeTo : edgeTo)</span><br><span class="line">            <span class="keyword">if</span> (anEdgeTo != <span class="keyword">null</span>)</span><br><span class="line">                edges.enqueue(anEdgeTo);</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> weight = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge e : edges())</span><br><span class="line">            weight += e.weight();</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Prim即时实现的性能："><a href="#Prim即时实现的性能：" class="headerlink" title="Prim即时实现的性能："></a>Prim即时实现的性能：</h4><ul><li>空间：V（最多只能添加V个顶点）</li><li>时间：ElogV（对E条边进行删除插入操作）</li></ul><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>相比较两种实现而言，在巨型稀疏图中，性能在时间上差不多（logE ~ logV），但是空间上即时实现的算法变为了常数因子V。</p><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>在MST中，贪心算法的另一种选择就是每次只添加所有边中权重最小的边。</p><blockquote><p>Kruskal算法将边按照权重顺序处理。每条边都可以看作是一个树，然后逐个由森林合并成为一颗树，最终完成。</p></blockquote><p>在合并的时候，需要检查树与树是否已经连接。这里我们选用<code>WeightedQuickUnionUF</code>算法，来检查即将合并的两个树的两个顶点是否已经在同一个树中（判断树与树是否已经连接）。</p><h3 id="WeightedQuickUnionUF算法"><a href="#WeightedQuickUnionUF算法" class="headerlink" title="WeightedQuickUnionUF算法"></a>WeightedQuickUnionUF算法</h3><p>是一种加权连接算法，可以用树的思想理解它，这里不做详细探讨，我会抽时间在别的篇章中介绍这一巧妙的算法。<a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter1_5/WeightedQuickUnionUF.java">算法实现</a></p><p>它提供<code>connected(int v,int w)</code>来检查v和w是否连接。性能为 O(1)。</p><p>它提供<code>union(int v,int w)</code>来连接v和w两点。性能为 O(logV)，V为总顶点数目。</p><h3 id="Kruskal实现"><a href="#Kruskal实现" class="headerlink" title="Kruskal实现"></a>Kruskal实现</h3><p>比Prim算法更简洁，理解起来也更容易。</p><figure class="highlight java"><figcaption><span>KruskalMST Kruskal算法</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_3/KruskalMST.java">KruskalMST.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalMST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Edge&gt; mst;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KruskalMST</span><span class="params">(EdgeWeightedGraph G)</span> </span>&#123;</span><br><span class="line">        weight = <span class="number">0.0</span>;</span><br><span class="line">        mst = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        MinPQ&lt;Edge&gt; pq = <span class="keyword">new</span> MinPQ&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Edge e : G.edges()) pq.insert(e);</span><br><span class="line">        WeightedQuickUnionUF uf = <span class="keyword">new</span> WeightedQuickUnionUF(G.V());</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; mst.size() &lt; G.V() - <span class="number">1</span>) &#123;</span><br><span class="line">            Edge e = pq.delMin();</span><br><span class="line">            <span class="keyword">int</span> v = e.either(), w = e.other(v);</span><br><span class="line">            <span class="keyword">if</span> (uf.connected(v, w)) <span class="keyword">continue</span>;</span><br><span class="line">            uf.union(v, w);</span><br><span class="line">            mst.enqueue(e);</span><br><span class="line">            weight += e.weight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul><li>空间：E（最多添加E条最小权重的边）</li><li>时间：ElogE（优先队列最多有E条边，每次操作最多2logE次比较）</li></ul><hr><p><em>参考文献：《算法导论》 《Algorithms, 4th Edition》</em></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;阅读此篇之前，需要了解&lt;a href=&quot;http://yifhong.com/2018/09/01/Graph-general/&quot;&gt;图论的基础知识&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最小生成树MST应用的领域十分广泛，它比普通的无向图（连通图）多了权重的属性，这就使最小生成树可以被用来评估成本最小化的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/tags/Algorithm/"/>
    
      <category term="Java" scheme="http://yif-hong.github.io/tags/Java/"/>
    
      <category term="Graph" scheme="http://yif-hong.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>图论——拓扑排序</title>
    <link href="http://yif-hong.github.io/2018/09/02/Graph-Topological/"/>
    <id>http://yif-hong.github.io/2018/09/02/Graph-Topological/</id>
    <published>2018-09-02T06:38:57.000Z</published>
    <updated>2020-09-12T08:12:15.278Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>阅读此篇之前，需要了解<a href="http://yifhong.com/2018/09/01/Graph-general/">图论的基础知识</a>。</em></p></blockquote><p>拓扑排序可以解决我们有<strong>优先级限制</strong>下的任务调度问题中的排序问题，或是类似Java中类的继承关系。</p><a id="more"></a><p>先来看下概念：</p><blockquote><p>拓扑排序：给定一个有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素。（或是说明无法做到这一点）</p></blockquote><p>通常在进行任务调度类问题需要3步走：</p><ol><li>指明任务和优先级。（确定顶点和有向边）</li><li>不断检测并去除有向图中的所有环，以确保存在可执行的方案。（构建有向图，检测环）</li><li>使用拓扑排序解决问题。（拓扑排序）</li></ol><p>有向图的构建，已经在<a href="http://yifhong.com/2018/09/02/Graph-general">图论的基础知识</a>中详细阐述了，接下来就是如何解决环的问题。</p><h2 id="有向环"><a href="#有向环" class="headerlink" title="有向环"></a>有向环</h2><p><em>如果任务x必须在y之前完成，y必须在z之前完成，z必须在x之前完成，出现了有向环，那么这个问题就是无解的。</em></p><h3 id="检测有向环"><a href="#检测有向环" class="headerlink" title="检测有向环"></a>检测有向环</h3><p>通过深度优先搜索DFS可以很简单的完成这个检测。</p><p>当我们进行DFS时，维护的递归调用栈表示的是系统正在遍历的有向路径，一旦我们找到了一条路径<code>v -&gt; w</code>已经存在于栈中，那么我们就找到了一个环。</p><p>相较于有向图而言，使用一个<code>boolean</code>数组<code>onStack[]</code>来保存遍历过的路径，作为检测依据。并用一个<code>Stack</code>来保存环。</p><figure class="highlight java"><figcaption><span>DirectedCycle 有向环的检测</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_2/DirectedCycle.java">DirectedCycle.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedCycle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; cycle;   <span class="comment">//有向环中的所有顶点（如果存在）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] onStack;      <span class="comment">//递归调用的栈上的所有顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedCycle</span><span class="params">(Digraph G)</span> </span>&#123;</span><br><span class="line">        onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">            <span class="keyword">if</span> (!marked[v])</span><br><span class="line">                dfs(G, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Digraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        onStack[v] = <span class="keyword">true</span>;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasCycle()) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                edgeTo[w] = v;</span><br><span class="line">                dfs(G, w);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (onStack[w]) &#123;</span><br><span class="line">                cycle = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != w; x = edgeTo[x])</span><br><span class="line">                    cycle.push(x);</span><br><span class="line">                cycle.push(w);</span><br><span class="line">                cycle.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onStack[v] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">cycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序数据结构"><a href="#拓扑排序数据结构" class="headerlink" title="拓扑排序数据结构"></a>拓扑排序数据结构</h2><h3 id="基于DFS的逆后序排序"><a href="#基于DFS的逆后序排序" class="headerlink" title="基于DFS的逆后序排序"></a>基于DFS的逆后序排序</h3><p>拓扑排序所需要的顶点顺序，其实只需要将DFS算法每次访问的顶点（DFS递归访问时，每个顶点只访问一次）采取逆后序排序即可。（压入栈中）</p><blockquote><p>原理：对于<code>v -&gt; w</code>，在进行DFS时递归访问，总是<code>dsf(w)</code>先于<code>dsf(v)</code>完成，故将完成<code>dfs()</code>访问一个顶点时压入栈即可完成<code>v -&gt; w</code>顺序。</p></blockquote><figure class="highlight java"><figcaption><span>DepthFirstOrder 基于DFS的逆后序排序</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_2/DepthFirstOrder.java">DepthFirstOrder.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstOrder</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; reversePost; <span class="comment">//所有顶点的逆后序排列(stack)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Digraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        ···</span><br><span class="line">        reversePost.push(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">reversePost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reversePost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑排序实现"><a href="#拓扑排序实现" class="headerlink" title="拓扑排序实现"></a>拓扑排序实现</h3><p>非常简单，就是检测环，如果是有向无环图<code>DAG</code>，则返回顶点逆后序排序即可。</p><figure class="highlight java"><figcaption><span>Topological 拓扑排序</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_2/Topological.java">Topological.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Topological</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Iterable&lt;Integer&gt; order;        <span class="comment">//顶点的拓扑排序,为所有顶点的逆后序排列。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Topological</span><span class="params">(Digraph G)</span> </span>&#123;</span><br><span class="line">        DirectedCycle cycleFinder = <span class="keyword">new</span> DirectedCycle(G);</span><br><span class="line">        <span class="keyword">if</span> (!cycleFinder.hasCycle()) &#123;</span><br><span class="line">            DepthFirstOrder dfs = <span class="keyword">new</span> DepthFirstOrder(G);</span><br><span class="line">            order = dfs.reversePost();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能："><a href="#性能：" class="headerlink" title="性能："></a>性能：</h3><blockquote><ul><li><strong>时间：和V+E成正比</strong></li></ul></blockquote><p>这是由于每次拓扑排序时，会进行两次DFS。</p><p>第一次DFS遍历有向图确保无环，此时V+E。第二次DFS产生逆后序排序，此时V+E。两次都访问了顶点和边，故与V+E成正比。</p><h2 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h2><blockquote><p>探寻两点之间是否互相可达，是有向图中的另一个重要部分——强连通分量。</p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>这是一种非常重要的抽象，可以理解为几个相互关联的部分（顶点）是否是一种类型的。比如程序员对于程序模块的划分、写书的作者对于话题或者书中知识点的分类、生物学食物链中的能量流动是否存在相互关系、巨型互联网中网页网站的分模块处理等等。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>想实现一个平方级的算法并不难，但是对于大型数据而言是不可接受的（大型稀疏图）。<br>这里介绍一个<code>Kosaraju算法</code>巧妙的实现。</p><ul><li>给定的有向图G，使用<code>DepthFirstOrder</code>来计算G的反向图Gr的逆后序排列，得到<code>order</code>。</li><li>在G的构造函数中DFS，但是DFS访问的顶点顺序根据<code>order</code>进行。</li></ul><p>实现简单，但是理解比较难。</p><blockquote><p>命题：用<code>Kosaraju算法</code>处理G，其构造函数中的每次递归都在同一个强连通分量中。<br>证明：</p><ol><li>首先证明每个和s强连通的顶点v都会在构造函数<code>dfs(G,s)</code>中访问到。（这个不难理解，反证法即可）</li><li>再证明v和s必然是强连通的。设v为<code>dfs(G,s)</code>中到达的某个顶点，那么G中必然存在s到v的路径。故只要证明存在v到s的路径即可。等价于证明Gr中存在s到v的路径。其中Gr中已经含有v到s的路径，故对Gr进行DFS时，<code>dfs(G,v)</code>必然先于<code>dfs(G,s)</code>结束，并且是在<code>dfs(G,s)</code>之后调用的，这个顺序是由DFS的递归访问导致的。所以此时说明了存在一条s到v的路径。</li></ol></blockquote><figure class="highlight java"><figcaption><span>KosarajuSCC 检测强连通分量</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_2/KosarajuSCC.java">KosarajuSCC.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KosarajuSCC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KosarajuSCC</span><span class="params">(Digraph G)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        DepthFirstOrder order = <span class="keyword">new</span> DepthFirstOrder(G);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s : order.reversePost()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[s]) &#123;</span><br><span class="line">                dfs(G, s);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Digraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        id[v] = count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v))</span><br><span class="line">            <span class="keyword">if</span> (!marked[w])</span><br><span class="line">                dfs(G, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stronglyConnected</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[v] == id[w];</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有向图的反转实现如下：</p><figure class="highlight java"><figcaption><span>Digraph 有向图反转</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_2/Digraph.java">Digraph.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Digraph</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Digraph <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Digraph R = <span class="keyword">new</span> Digraph(V);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : adj[v])</span><br><span class="line">                R.addEdge(w, v);</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能：-1"><a href="#性能：-1" class="headerlink" title="性能："></a>性能：</h3><blockquote><p><strong>预处理</strong></p><ul><li>空间：与V+E成正比</li><li>时间：与V+E成正比</li></ul></blockquote><blockquote><p><strong>查询</strong></p><ul><li>时间：线性</li></ul></blockquote><hr><p><em>参考文献：《算法导论》 《Algorithms, 4th Edition》</em></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;阅读此篇之前，需要了解&lt;a href=&quot;http://yifhong.com/2018/09/01/Graph-general/&quot;&gt;图论的基础知识&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拓扑排序可以解决我们有&lt;strong&gt;优先级限制&lt;/strong&gt;下的任务调度问题中的排序问题，或是类似Java中类的继承关系。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/tags/Algorithm/"/>
    
      <category term="Java" scheme="http://yif-hong.github.io/tags/Java/"/>
    
      <category term="Graph" scheme="http://yif-hong.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>图论——基础</title>
    <link href="http://yif-hong.github.io/2018/09/01/Graph-general/"/>
    <id>http://yif-hong.github.io/2018/09/01/Graph-general/</id>
    <published>2018-09-01T05:46:49.000Z</published>
    <updated>2020-09-12T08:12:15.278Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>如何确定两点连通？如何确定两点有最短路径？最短路径是什么？任务的优先调度如何安排？如何在最短时间内安排有时间限制的任务优先调度？人际关系或是社交网络的关系该如何表达？……</em></p></blockquote><p>如果你想探寻以上类似的问题，那么图的模型对你非常有帮助。</p><a id="more"></a><blockquote><p>精力有限，图论无法像之前一样，详细解释算法的推导和原理，感兴趣的朋友请自行查阅资料，推荐《算法导论》和《Algorithm》。</p><footer><strong>Yif</strong><cite>Hong</cite></footer></blockquote><ul><li>图由边E和顶点V组成。</li><li>图最重要的四种模型分别是无向图、有向图、加权图、加权有向图，因而边对应为无向边、有向边、加权无向边、加权有向边，顶点则为边的顶点。</li><li>将各个顶点和边组合起来，可以形成许多大小不一的树或环，进而组成森林，构成图。</li></ul><p>这里先介绍几个基本的概念：</p><ol><li>自环：一条连接一个顶点和其自身的边。</li><li>平行边：连接同一对顶点的两条边。</li><li>树：是一幅无环连通图。</li><li>稠密图：指的是顶点大部分互相连接的图。</li><li>稀疏图：指的是顶点之间连接较少的图。(v ~cV)</li><li>度数：一个顶点所连接的边的数目。</li></ol><h1 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h1><h2 id="无向图-Graph"><a href="#无向图-Graph" class="headerlink" title="无向图 Graph"></a>无向图 Graph</h2><p>我们可以通过<strong>邻接表</strong>或<strong>邻接矩阵</strong>来表示无向图。</p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>大部分情况下，我们研究的是稀疏图，邻接表要优于邻接矩阵。某些情况下，邻接矩阵优于邻接表。比如在稠密图中。</p><ul><li>邻接表是一种数组+背包Bag（一种无序的链表存储结构）组成的数据结构。</li></ul><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><h5 id="存储空间-V-E"><a href="#存储空间-V-E" class="headerlink" title="存储空间 V+E"></a>存储空间 V+E</h5><h5 id="添加边的时间为常数"><a href="#添加边的时间为常数" class="headerlink" title="添加边的时间为常数"></a>添加边的时间为常数</h5><h5 id="遍历顶点v的邻接表时间与v的度数成正比"><a href="#遍历顶点v的邻接表时间与v的度数成正比" class="headerlink" title="遍历顶点v的邻接表时间与v的度数成正比"></a>遍历顶点v的邻接表时间与v的度数成正比</h5><p>下面展示了无向图的基本数据结构，其中的<a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter1_3/Bag.java">背包Bag实现</a>：</p><figure class="highlight java"><figcaption><span>Graph 无向图的数据结构</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_1/Graph.java">Graph.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V;        <span class="comment">//num of vertex, 顶点的数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;              <span class="comment">//num of edge</span></span><br><span class="line">    <span class="keyword">private</span> Bag&lt;Integer&gt;[] adj; <span class="comment">//邻接表, implement of Bag</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (Bag&lt;Integer&gt;[]) <span class="keyword">new</span> Bag[V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            adj[v] = <span class="keyword">new</span> Bag&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v &gt; V || v &lt; <span class="number">0</span> || w &gt; V || w &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (v == w) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Don&#x27;t allow self-loop!&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (adj[v].contains(w) || adj[w].contains(v)) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Don&#x27;t allow parallel-edge!&quot;</span>);</span><br><span class="line">        adj[v].add(w);</span><br><span class="line">        adj[w].add(v);</span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (V() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> adj[v].contains(w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基础介绍完了，接下来进入经典的深度优先搜索和广度优先搜索，这两个可谓是实用最广泛的暴力遍历算法了。</p><h2 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h2><p>深度优先搜索的模型，最早可以追溯到一种走迷宫的问题(Tremaux搜索)，如何探索迷宫中所有的通道：</p><ol><li>选择一个起始点出发，并在你走过的每条路都做好标记（放上绳子）。</li><li>标记你所有第一次来到的路口。</li><li>当来到了已经标记过的路口时，回退到上一个路口，换一条路走。</li><li>当回退的路口无路可走时，继续回退。</li></ol><p>这里，路口就是顶点，路径就是边。</p><ul><li>通过理解这个类似<strong>Stack LIFO栈</strong>的流程，可以轻松的完成算法构建。</li></ul><blockquote><p>深度优先搜索更注重两个顶点是否连通，并不关心路径长短。</p></blockquote><figure class="highlight java"><figcaption><span>DepthFirstSearch 深度优先搜索</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_1/DepthFirstSearch.java">DepthFirstSearch.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstSearch</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph G, <span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        marked[V] = <span class="keyword">true</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(V)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                edgeTo[w] = V;</span><br><span class="line">                dfs(G, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != s; x = edgeTo[x])</span><br><span class="line">            path.push(x);</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索 BFS"></a>广度优先搜索 BFS</h2><blockquote><p>相对于深度优先搜索而言，广度优先搜索更注重<strong>单点最短路径</strong>的选择。</p></blockquote><p>同样以走迷宫的模型举例，相对于DFS一个人探索迷宫而言，BFS更像是团队合作。</p><ol><li>在遇到路口时，会选择好几个人去同时探寻迷宫。</li><li>当两人相遇时，会合二为一，并选用先到的人继续探寻。</li></ol><ul><li>所有深度优先搜索能实现的，广度优先搜索也可以实现，只是效率上的问题有差异。</li><li>广度优先搜索的实现思想更类似于 <strong>Queue FIFO队列</strong>。</li></ul><figure class="highlight java"><figcaption><span>BreadthFirstPaths 广度优先搜索</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_1/BreadthFirstPaths.java">BreadthFirstPaths.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreadthFirstPaths</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;        <span class="comment">//startup</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;   <span class="comment">//vertex marked</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;       <span class="comment">//last vertex in road</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadthFirstPaths</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        bfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        marked[s] = <span class="keyword">true</span>;</span><br><span class="line">        queue.enqueue(s);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = queue.dequeue();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                    edgeTo[w] = v;</span><br><span class="line">                    marked[w] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.enqueue(w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != s; x = edgeTo[x])</span><br><span class="line">            path.push(x);</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//0~v distance</span></span><br><span class="line">        <span class="keyword">int</span> dis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) <span class="keyword">return</span> dis;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != s; x = edgeTo[x])</span><br><span class="line">            dis++;</span><br><span class="line">        <span class="keyword">return</span> dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><p>有向图和无向图的区别，仅在于边变为有向了。在图的构建上，仅需更改<code>addEdge()</code>，由邻接表的双向添加，变为单向添加边。</p><figure class="highlight java"><figcaption><span>Digraph 有向图</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_2/Digraph.java">Digraph.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Digraph</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        ···</span><br><span class="line">        adj[v].add(w);</span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有向图的可达性"><a href="#有向图的可达性" class="headerlink" title="有向图的可达性"></a>有向图的可达性</h3><p>就是使用有向图进行深度优先搜索，很简单，暴力搜索邻接表即可。</p><figure class="highlight java"><figcaption><span>DirectedDFS 有向图深度优先搜索</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_2/DirectedDFS.java">DirectedDFS.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedDFS</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> marked[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedDFS</span><span class="params">(Digraph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受多个顶点的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedDFS</span><span class="params">(Digraph G, Iterable&lt;Integer&gt; sources)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s : sources)</span><br><span class="line">            <span class="keyword">if</span> (!marked[s]) dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Digraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v))</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) dfs(G, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">marked</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标记-java-GC机制"><a href="#标记-java-GC机制" class="headerlink" title="标记-java GC机制"></a>标记-java GC机制</h4><p>在这里，有向图可以被应用于GC模型。顶点表示对象，有向边表示对象对另一个对象的引用。有一个根对象（起点）指向所有堆上的对象，周期性的执行DFS，而只要发现某个对象无访问路径，则记为可回收对象，以腾出空闲内存。</p><p>当然，实际的GC算法更为复杂，这里只是举例简化，便于理解。</p><h4 id="有向图的路径"><a href="#有向图的路径" class="headerlink" title="有向图的路径"></a>有向图的路径</h4><p>通过像Graph结构一样，添加<code>edgeTo[]</code>记录路径，并引入<code>Digraph</code>结构来表示，即可轻松得到<a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_2/DepthFirstDirectedPath.java">有向路径DFS</a>和<a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter4_2/BreadthFirstDirectedPaths.java">有向<strong>最短</strong>路径BFS</a>的实现。</p><hr><p><em>参考文献：《算法导论》 《Algorithms, 4th Edition》</em></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;如何确定两点连通？如何确定两点有最短路径？最短路径是什么？任务的优先调度如何安排？如何在最短时间内安排有时间限制的任务优先调度？人际关系或是社交网络的关系该如何表达？……&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你想探寻以上类似的问题，那么图的模型对你非常有帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/tags/Algorithm/"/>
    
      <category term="Java" scheme="http://yif-hong.github.io/tags/Java/"/>
    
      <category term="Graph" scheme="http://yif-hong.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode刷题记录（日更）</title>
    <link href="http://yif-hong.github.io/2018/08/22/LeetcodeExercise/"/>
    <id>http://yif-hong.github.io/2018/08/22/LeetcodeExercise/</id>
    <published>2018-08-21T16:26:25.000Z</published>
    <updated>2020-09-12T08:12:15.279Z</updated>
    
    <content type="html"><![CDATA[<ul><li>最近开始慢慢刷Leetcode题目了，为了督促自己，挖个坑记录下，顺便分享一下答案及思路。</li></ul><blockquote><p><strong>“对于程序员而言，刷了Leetcode不一定能拿offer，但是不刷肯定拿不到offer。”</strong></p><footer><strong>Lusion</strong><cite>鲁迅</cite></footer></blockquote><a id="more"></a><p><img src="/2018/08/22/LeetcodeExercise/luxun.jpg" alt="Lusion"></p><p><strong>Update：2018年11月13日16:29:32</strong></p><blockquote><p>读前须知：</p></blockquote><ul><li>由于是按<code>tag</code>刷的，由简单-&gt;困难，故不是按照题号刷的。如果有需要查找题目，请直接<code>Command-F</code>或<code>Ctrl+F</code>搜索对应<strong>题号</strong>或<strong>关键字</strong>即可。</li><li><strong>解法并不唯一</strong>。本篇只是个人的拙见，也并不意味着这是最优解 (ಥ﹏ಥ)</li><li>如果有更好的想法欢迎向<a href="https://github.com/yif-hong/Algorithms-4th-Exercise/tree/master/src/LeetCodeExcercise">我的Github</a>砸<a href="https://github.com/yif-hong/Algorithms-4th-Exercise/pulls">Pull requests</a>！感激不尽 (๑˙―˙๑)</li><li>想联系我请戳<a href="mailto:h759233960@163.com">邮箱</a>，谢绝广告和培训机构，蟹蟹 (ง •̀_•́)ง</li></ul><figure class="highlight java"><figcaption><span>724. 寻找数组的中心索引 Find Pivot Index</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex724.java">ex724.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        sum += num;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">            left += nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> right = sum - nums[i] - left;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>050. Pow(x, n)</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex050.java">ex050.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i != <span class="number">0</span>; i /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) result *= x;</span><br><span class="line">        x *= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">0</span> ? <span class="number">1</span> / result : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>035. 搜索插入位置 Search Insert Position</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex035.java">ex035.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>744. 寻找比目标字母大的最小字母 Find Smallest Letter Greater Than Target</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex744.java">ex744.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = letters.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &gt;= letters[hi]) <span class="keyword">return</span> letters[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (letters[mid] &lt;= target) lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> hi = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> letters[lo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>852. 山脉数组的峰顶索引 Peak Index in a Mountain Array</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex852.java">ex852.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">1</span>, hi = A.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] &lt;= A[mid - <span class="number">1</span>]) hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &lt;= A[mid + <span class="number">1</span>]) lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray2</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (A[i - <span class="number">1</span>] &gt; A[i])</span><br><span class="line">            <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>029. 两数相除 Divide Two Integers</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex029.java">ex029.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果被除数大于或等于除数，则进行如下循环，定义变量t等于除数，定义计数p</span></span><br><span class="line"><span class="comment">//当t的两倍小于等于被除数时，进行如下循环，t扩大一倍，p扩大一倍，然后更新res和m</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (divisor == <span class="number">0</span> || (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">long</span> m = Math.abs(dividend), n = Math.abs(divisor), res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign = (dividend &lt; <span class="number">0</span>) ^ (divisor &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>) (sign &gt; <span class="number">0</span> ? m : -m);</span><br><span class="line">    <span class="keyword">while</span> (m &gt;= n) &#123;</span><br><span class="line">        <span class="keyword">long</span> t = n, p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (m &gt;= (t &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            t &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            p &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += p;</span><br><span class="line">        m -= t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (sign &gt; <span class="number">0</span> ? res : -res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>658. 找到K个最接近的元素 Find K Closest Elements</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex658.java">ex658.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findClosestElements</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(k);</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = arr.length - k - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(x - arr[mid]) &gt; Math.abs(x - arr[mid + k]))</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> hi = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        list.add(arr[lo + i]);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非二分法，采用首尾逼近</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findClosestElements2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) list.add(i);</span><br><span class="line">    <span class="keyword">while</span> (list.size() &gt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x - list.get(<span class="number">0</span>) &lt;= list.get(list.size() - <span class="number">1</span>) - x)</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> list.remove(list.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>034. 在排序数组中查找元素的第一个和最后一个位置 Find First and Last Position of Element in Sorted Array Array</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex034.java">ex034.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] range = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">1</span>) <span class="keyword">return</span> range;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> hi = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[hi] != target) <span class="keyword">return</span> range;</span><br><span class="line">    range[<span class="number">0</span>] = hi;</span><br><span class="line">    hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    range[<span class="number">1</span>] = lo - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> range;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>153. 寻找旋转排序数组中的最小值 Find Minimum in Rotated Sorted Array</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex153.java">ex153.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) <span class="keyword">return</span> nums[i];</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[lo] &lt;= nums[hi]) <span class="keyword">return</span> nums[lo];</span><br><span class="line">    <span class="keyword">while</span> (lo != hi - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[lo]) lo = mid;</span><br><span class="line">        <span class="keyword">else</span> hi = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[lo] &lt; nums[hi] ? nums[lo] : nums[hi];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>162. 寻找峰值 Find Peak Element</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex162.java">ex162.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>]) lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> hi = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> nums.length - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>278. 第一个错误的版本 First Bad Version</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex278.java">ex278.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">1</span>, hi = n;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (isBadVersion(mid)) hi = mid;</span><br><span class="line">        <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>033. 搜索旋转排序数组 Search in Rotated Sorted Array</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex033.java">ex033.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[lo]) &#123;</span><br><span class="line">            <span class="comment">//左边有序 lo...mid</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target &amp;&amp; target &gt;= nums[lo]) hi = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[hi]) &#123;</span><br><span class="line">            <span class="comment">//右边有序 mid...hi</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[hi]) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>374. 猜数字大小 Guess Number Higher or Lower</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex374.java">ex374.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result = guess(mid);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (result &lt; <span class="number">0</span>) hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>069. x 的平方根 Sqrt(x)</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex069.java">ex069.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="comment">//right = x</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = x / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x / mid &gt;= mid) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//牛顿逼近法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (last != res) &#123;</span><br><span class="line">        last = res;</span><br><span class="line">        res = (res + x / res) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>430. 扁平化多级双向链表 Flatten a Multilevel Doubly Linked List</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex430.java">ex430.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归1，一层一层递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">flatten</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.child != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = curr.next;</span><br><span class="line">            Node nextLayer = flatten(curr.child);</span><br><span class="line">            curr.next = nextLayer;</span><br><span class="line">            nextLayer.prev = curr;</span><br><span class="line">            curr.child = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (nextLayer.next != <span class="keyword">null</span>) nextLayer = nextLayer.next;</span><br><span class="line">            nextLayer.next = next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) next.prev = nextLayer;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归2，一个一个递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">flatten2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head.child == <span class="keyword">null</span>) head.next = flatten2(head.next);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node next = flatten2(head.next);</span><br><span class="line">        Node nextLayer = flatten2(head.child);</span><br><span class="line">        nextLayer.prev = head;</span><br><span class="line">        head.next = nextLayer;</span><br><span class="line">        head.child = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (nextLayer.next != <span class="keyword">null</span>) nextLayer = nextLayer.next;</span><br><span class="line">        nextLayer.next = next;</span><br><span class="line">        <span class="keyword">if</span> (next != <span class="keyword">null</span>) next.prev = nextLayer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代解决</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">flatten3</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node curr = head; curr != <span class="keyword">null</span>; curr = curr.next) &#123;</span><br><span class="line">        Node next = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (curr.child != <span class="keyword">null</span>) &#123;</span><br><span class="line">            curr.next = curr.child;</span><br><span class="line">            curr.child.prev = curr;</span><br><span class="line">            curr.child = <span class="keyword">null</span>;</span><br><span class="line">            Node temp = curr.next;</span><br><span class="line">            <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) temp = temp.next;</span><br><span class="line">            temp.next = next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) next.prev = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node prev;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="keyword">public</span> Node child;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, Node _prev, Node _next, Node _child)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        prev = _prev;</span><br><span class="line">        next = _next;</span><br><span class="line">        child = _child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>061. 旋转链表 Rotate List</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex061.java">ex061.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr.next = head;</span><br><span class="line">    sum = sum - k % sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i++)</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    head = curr.next;</span><br><span class="line">    curr.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>138. 复制带随机指针的链表 Copy List with Random Pointer</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex138.java">ex138.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    RandomListNode node = <span class="keyword">new</span> RandomListNode(-<span class="number">1</span>);</span><br><span class="line">    node.next = head;</span><br><span class="line">    RandomListNode curr = node;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> RandomListNode(head.label);</span><br><span class="line">        curr.next.random = head.random == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> RandomListNode(head.random.label);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> label;</span><br><span class="line">    RandomListNode next, random;</span><br><span class="line"></span><br><span class="line">    RandomListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">this</span>.label = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>025. k个一组翻转链表 Reverse Nodes in k-Group</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex025.java">ex025.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代解决</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    ListNode pre = dummyHead;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (sum &gt;= k) &#123;</span><br><span class="line">        curr = pre.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ListNode node = curr.next;</span><br><span class="line">            curr.next = node.next;</span><br><span class="line">            node.next = pre.next;</span><br><span class="line">            pre.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = curr;</span><br><span class="line">        sum -= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归解决</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup2</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode nextFirst = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextFirst == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        nextFirst = nextFirst.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode first = reverseList(head, nextFirst);</span><br><span class="line">    head.next = reverseKGroup2(nextFirst, k);</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode first, ListNode nextFirst)</span> </span>&#123;</span><br><span class="line">    ListNode pre = nextFirst;</span><br><span class="line">    <span class="keyword">while</span> (first != nextFirst) &#123;</span><br><span class="line">        ListNode temp = first.next;</span><br><span class="line">        first.next = pre;</span><br><span class="line">        pre = first;</span><br><span class="line">        first = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>019. 删除链表的倒数第N个节点 Remove Nth Node From End of List</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex019.java">ex019.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span>) <span class="keyword">return</span> head.next;<span class="comment">//删除第一个结点</span></span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd2</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    ListNode slow = dummyHead;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>142. 环形链表 II Linked List Cycle II</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex142.java">ex142.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode slow = head.next, fast = head.next.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//检测到无环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测到有环，a指head到环起点的距离，b指环起点到相交点距离，b+c为环的周长</span></span><br><span class="line">    <span class="comment">// 2(a+b)=a+b+n(b+c);a=(n-1)b+nc=(n-1)(b+c)+c;</span></span><br><span class="line">    <span class="comment">// 意味着从起点出发走a，必然与环内循环的点相交于环的起点。</span></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head, fast = slow;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>082. 删除排序链表中的重复元素 II Remove Duplicates from Sorted List II</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex082.java">ex082.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">if</span> (head.val == head.next.val) &#123;</span><br><span class="line">        <span class="comment">//如果当前结点是重复结点，则找到第一个与当前结点不同的开始递归。</span></span><br><span class="line">        ListNode node = head.next;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span> &amp;&amp; node.val == head.val) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deleteDuplicates(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前结点不是重复结点，保留当前结点，从下个结点开始递归。</span></span><br><span class="line">        head.next = deleteDuplicates(head.next);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    ListNode pre = dummyHead;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.val == curr.next.val) &#123;</span><br><span class="line">            <span class="comment">//出现重复</span></span><br><span class="line">            <span class="keyword">while</span> (curr.next != <span class="keyword">null</span> &amp;&amp; curr.val == curr.next.val)</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            pre.next = curr.next;</span><br><span class="line">            curr.next = <span class="keyword">null</span>;</span><br><span class="line">            curr = pre.next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>086. 分隔链表 Partition List</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex086.java">ex086.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不生成新链表，变化顺序为：</span></span><br><span class="line"><span class="comment">//1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2</span></span><br><span class="line"><span class="comment">//1 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5 -&gt; 2</span></span><br><span class="line"><span class="comment">//1 -&gt; 2 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    ListNode pre = dummyHead;</span><br><span class="line">    <span class="keyword">while</span> (pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.val &lt; x) &#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode large = pre.next;</span><br><span class="line">    <span class="keyword">while</span> (large != <span class="keyword">null</span> &amp;&amp; large.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (large.next.val &gt;= x) &#123;</span><br><span class="line">            large = large.next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode small = large.next;</span><br><span class="line">        large.next = small.next;</span><br><span class="line">        small.next = pre.next;</span><br><span class="line">        pre.next = small;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成新链表（比x小的创建新链表），变化顺序为：</span></span><br><span class="line"><span class="comment">//Original: 1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2</span></span><br><span class="line"><span class="comment">//New:</span></span><br><span class="line"><span class="comment">//Original: 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2</span></span><br><span class="line"><span class="comment">//New:      1</span></span><br><span class="line"><span class="comment">//Original: 4 -&gt; 3 -&gt; 5 -&gt; 2</span></span><br><span class="line"><span class="comment">//New:      1 -&gt; 2</span></span><br><span class="line"><span class="comment">//Original: 4 -&gt; 3 -&gt; 5</span></span><br><span class="line"><span class="comment">//New:      1 -&gt; 2 -&gt; 2</span></span><br><span class="line"><span class="comment">//Original:</span></span><br><span class="line"><span class="comment">//New:      1 -&gt; 2 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition2</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode large = dummyHead, small = newHead;</span><br><span class="line">    <span class="keyword">while</span> (large.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (large.next.val &lt; x) &#123;</span><br><span class="line">            small.next = large.next;</span><br><span class="line">            small = small.next;</span><br><span class="line">            large.next = large.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            large = large.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接小链表和大链表</span></span><br><span class="line">    small.next = dummyHead.next;</span><br><span class="line">    <span class="keyword">return</span> newHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>092. 反转链表 II Reverse Linked List II</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex092.java">ex092.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    ListNode first = dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode curr = first.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - m; i++) &#123;</span><br><span class="line">        ListNode node = curr.next;</span><br><span class="line">        curr.next = node.next;</span><br><span class="line">        node.next = first.next;</span><br><span class="line">        first.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决的不好，不易理解，纯靠画图完成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween2</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>, s = head, t = head, curr = head;</span><br><span class="line">    <span class="comment">//构造结构</span></span><br><span class="line">    <span class="comment">//  1   -&gt;  2   -&gt;  3   -&gt;  4   -&gt;  5   -&gt;  null, m=2, n=4</span></span><br><span class="line">    <span class="comment">//pre      preS     s               t</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (i &lt;= n) &amp;&amp; curr != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; m) pre = curr;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        t = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode preS;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="keyword">null</span>)</span><br><span class="line">        preS = pre.next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        preS = head;</span><br><span class="line">    s = preS.next;</span><br><span class="line">    <span class="comment">//把从s到t的前一个逆序</span></span><br><span class="line">    <span class="comment">//  1   -&gt;  2  &lt;-&gt; 3   &lt;-  4        5   -&gt;  null, m=2, n=4</span></span><br><span class="line">    <span class="comment">//pre    preNext           preS     st</span></span><br><span class="line">    ListNode preNext = preS;</span><br><span class="line">    <span class="keyword">while</span> (s != t &amp;&amp; s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode temp = s.next;</span><br><span class="line">        s.next = preS;</span><br><span class="line">        preS = s;</span><br><span class="line">        s = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后整理链表顺序</span></span><br><span class="line">    preNext.next = t;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="keyword">null</span>)</span><br><span class="line">        pre.next = preS;</span><br><span class="line">    <span class="keyword">else</span> head = preS;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>445. 两数相加 II Add Two Numbers II</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex445.java">ex445.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不反转链表通过Stack存储数据并弹出，然后模仿Stack在头部添加新结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ListNode p = l1, q = l2;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack1.push(p.val);</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack2.push(q.val);</span><br><span class="line">        q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    ListNode first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack1.isEmpty() || !stack2.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = stack1.isEmpty() ? <span class="number">0</span> : stack1.pop();</span><br><span class="line">        <span class="keyword">int</span> y = stack2.isEmpty() ? <span class="number">0</span> : stack2.pop();</span><br><span class="line">        <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        ListNode temp = first;</span><br><span class="line">        first = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        first.next = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ListNode temp = first;</span><br><span class="line">        first = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        first.next = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers2</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode rl1 = reverse(l1);</span><br><span class="line">    ListNode rl2 = reverse(l2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode curr = dummyHead;</span><br><span class="line">    ListNode p = rl1, q = rl2;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = p != <span class="keyword">null</span> ? p.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = q != <span class="keyword">null</span> ? q.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    <span class="keyword">return</span> reverse(dummyHead.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode temp = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>725. 分隔链表 Split Linked List in Parts</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex725.java">ex725.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">//总数</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    ListNode curr = root;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = root;</span><br><span class="line">    <span class="comment">//每个部分的基础大小</span></span><br><span class="line">    <span class="keyword">int</span> per = sum &lt; k ? <span class="number">1</span> : sum / k;</span><br><span class="line">    <span class="comment">//额外分配多1的结点数(extra&lt;per)</span></span><br><span class="line">    <span class="keyword">int</span> extra = sum &lt; k ? <span class="number">0</span> : sum % k;</span><br><span class="line"></span><br><span class="line">    ListNode[] result = <span class="keyword">new</span> ListNode[k];</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++, --extra) &#123;</span><br><span class="line">        result[i] = curr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; (j &lt; per + (extra &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>)) &amp;&amp; curr != <span class="keyword">null</span>; j++) &#123;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) pre.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>143. 重排链表 Reorder List</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex143.java">ex143.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast = head, slow = head, curr = head;</span><br><span class="line">    ListNode reverse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//寻找中间结点slow</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将后半部分链表翻转</span></span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode temp = slow.next;</span><br><span class="line">        slow.next = reverse;</span><br><span class="line">        reverse = slow;</span><br><span class="line">        slow = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并两个链表C-R-C-R-C-R···</span></span><br><span class="line">    <span class="comment">//末尾结点两种情况：</span></span><br><span class="line">    <span class="comment">//1.C和R为同一个，以R!=null为循环结束判断条件:···-C/R-null</span></span><br><span class="line">    <span class="comment">//2.R为最后一个，以R.next!=null为循环结束判断条件:···-C-R-null</span></span><br><span class="line">    <span class="keyword">while</span> (reverse != <span class="keyword">null</span> &amp;&amp; reverse.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        ListNode tempR = reverse.next;</span><br><span class="line">        curr.next = reverse;</span><br><span class="line">        reverse.next = temp;</span><br><span class="line">        curr = temp;</span><br><span class="line">        reverse = tempR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>817. Linked List Components</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex817.java">ex817.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numComponents</span><span class="params">(ListNode head, <span class="keyword">int</span>[] G)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; g = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : G) g.add(i);</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g.contains(head.val)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || !g.contains(head.next.val))</span><br><span class="line">                num++;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numComponents2</span><span class="params">(ListNode head, <span class="keyword">int</span>[] G)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; g = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : G) g.add(i);</span><br><span class="line">    <span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g.contains(head.val)) &#123;</span><br><span class="line">            ++nums;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            <span class="keyword">while</span> (next != <span class="keyword">null</span> &amp;&amp; g.contains(next.val)) &#123;</span><br><span class="line">                next = next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>328. 奇偶链表 Odd Even Linked List</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex328.java">ex328.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode odd = head;</span><br><span class="line">    ListNode even = head.next;</span><br><span class="line">    ListNode evenHead = even;</span><br><span class="line">    <span class="keyword">while</span> (even != <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        odd.next = even.next;</span><br><span class="line">        odd = odd.next;</span><br><span class="line">        even.next = odd.next;</span><br><span class="line">        even = even.next;</span><br><span class="line">    &#125;</span><br><span class="line">    odd.next = evenHead;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>024. 两两交换链表中的节点 Swap Nodes in Pairs</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex024.java">ex024.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span> &amp;&amp; head.next != <span class="keyword">null</span>)</span><br><span class="line">        head = head.next;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>)</span><br><span class="line">            pre.next = curr.next;</span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        curr.next = temp.next;</span><br><span class="line">        temp.next = curr;</span><br><span class="line">        pre = curr;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>707. 设计链表 Design Linked List</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex707.java">ex707.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码略长……直接去github看吧 三三三c⌒っﾟДﾟ)っ</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>160. 相交链表 Intersection of Two Linked Lists</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex160.java">ex160.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//A + B = B + A;</span></span><br><span class="line">    <span class="comment">//(a+intersection)+(b+intersection)=(b+intersection)+(a+intersection)</span></span><br><span class="line">    <span class="comment">//遍历A+B 和 B+A，若相交,则最后必然会有相交点。</span></span><br><span class="line">    ListNode p = headA, q = headB;</span><br><span class="line">    <span class="keyword">while</span> (p != q) &#123;</span><br><span class="line">        p = p != <span class="keyword">null</span> ? p.next : headB;</span><br><span class="line">        q = q != <span class="keyword">null</span> ? q.next : headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>234. 回文链表 Palindrome Linked List</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex234.java">ex234.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空链表或是单结点链表为true</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//判断是否为奇数个数的链表</span></span><br><span class="line">    <span class="keyword">boolean</span> single = <span class="keyword">false</span>;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//遍历链表slow至中序，并将pre作为前段逆序，若总结点数为count，则sum -&gt; Node(i &lt;= count/2)</span></span><br><span class="line">    <span class="comment">//i属于0 ~ count-1</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (fast != <span class="keyword">null</span>)</span><br><span class="line">            single = fast.next == <span class="keyword">null</span>;</span><br><span class="line">        ListNode temp = slow.next;</span><br><span class="line">        slow.next = pre;</span><br><span class="line">        pre = slow;</span><br><span class="line">        slow = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果为奇数链表，slow需要下移一位</span></span><br><span class="line">    <span class="comment">//1 2 1</span></span><br><span class="line">    <span class="comment">//P S ? F</span></span><br><span class="line">    <span class="keyword">if</span> (single) slow = slow.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pre.val != slow.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>002. 两数相加 Add Two Numbers</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex002.java">ex002.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = p != <span class="keyword">null</span> ? p.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = q != <span class="keyword">null</span> ? q.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>876. 链表的中间结点 Middle of the Linked List</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex876.java">ex876.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        total++;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>206. 反转链表 Reverse Linked List</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex206.java">ex206.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归解决</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span> &amp;&amp; head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode reverseHead = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> reverseHead;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代解决</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        curr.next = pre;</span><br><span class="line">        pre = curr;</span><br><span class="line">        curr = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>237. 删除链表中的节点 Delete Node in a Linked List</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex237.java">ex237.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    node.val = node.next.val;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>001. 两数之和 Two Sum</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex001.java">ex001.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == nums || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">            temp[<span class="number">0</span>] = map.get(target - nums[i]);</span><br><span class="line">            temp[<span class="number">1</span>] = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>704. 二分查找 Binary Search</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex704.java">ex704.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == nums[lo]) <span class="keyword">return</span> lo;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (nums[lo] &lt; nums[hi]) &#123;</span><br><span class="line">        mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (lo == mid || hi == mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[lo]) <span class="keyword">return</span> lo;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target == nums[hi]) <span class="keyword">return</span> hi;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid]) hi = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) lo = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>083. 删除排序链表中的重复元素 Remove Duplicates from Sorted List</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex083.java">ex083.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.val == curr.next.val) &#123;</span><br><span class="line">            curr.next = curr.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>203. 删除链表中的节点 Remove Linked List Elements</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex203.java">ex203.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.next.val == val) &#123;</span><br><span class="line">            curr.next = curr.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements2</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    head.next = removeElements2(head.next, val);</span><br><span class="line">    <span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>021. 合并两个有序链表 Merge Two Sorted Lists</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex021.java">ex021.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在数组中可以使用归并排序-merge</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode curr = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode head;</span><br><span class="line">    head = curr;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        curr.next = l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        curr.next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists2</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    ListNode head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        head = l1;</span><br><span class="line">        head.next = mergeTwoLists2(l1.next, l2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = l2;</span><br><span class="line">        head.next = mergeTwoLists2(l1, l2.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>141. 环形链表 Linked List Cycle</span><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/LeetCodeExcercise/ex141.java">ex141.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.val == <span class="number">0x7fffffff</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        head.val = <span class="number">0x7fffffff</span>;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;最近开始慢慢刷Leetcode题目了，为了督促自己，挖个坑记录下，顺便分享一下答案及思路。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;“对于程序员而言，刷了Leetcode不一定能拿offer，但是不刷肯定拿不到offer。”&lt;/strong&gt;&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;Lusion&lt;/strong&gt;&lt;cite&gt;鲁迅&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yif-hong.github.io/categories/Leetcode/"/>
    
    
      <category term="Java" scheme="http://yif-hong.github.io/tags/Java/"/>
    
      <category term="Leetcode" scheme="http://yif-hong.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>散列表</title>
    <link href="http://yif-hong.github.io/2018/08/19/HashTable/"/>
    <id>http://yif-hong.github.io/2018/08/19/HashTable/</id>
    <published>2018-08-18T17:36:46.000Z</published>
    <updated>2020-09-12T08:12:15.278Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter3_4/SeparateChainingHashST.java"><strong>链表</strong>实现 Github源码</a><br><a href="https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter3_4/LinearProbingHastST.java"><strong>数组</strong>实现 Github源码</a></p></blockquote><p>如果你需要一个<strong>简单</strong>而不失优雅的<strong>无序</strong>数据表，那么散列表一定是你的首选。</p><blockquote><p>在我们<strong>分布较好</strong>（近似均摊）的散列表内，查找、插入等操作一般在<strong>常数级别</strong>。</p></blockquote><p> <em>所有的数据结构都是在时间与空间上作出了平衡选择，而散列表则非常好的找到了平衡点。</em></p><a id="more"></a><p>散列表的难度比较简单，核心难度在于如何设计出一个优秀的散列函数，可以使我们均匀的分布每个键值。幸运的是，Java已经为我们准备好了不少常用的数据类型（<code>Integer, String, Double, File, URL等</code>）的散列函数——<code>hashCode()</code>。</p><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>对于散列表而言，所有存储的键值，不论是什么类型的数据，都要通过散列函数转化为数组中的索引实现存储。而如何设计优秀散列函数，一直是算法专家和数学专家的问题。我们在这里仅提供一种简单思路。</p><ul><li>假设散列表大小为M长度的整数数组，则每个存储的键值都应该分布在 0~M-1的数组区间。</li></ul><blockquote><p>假设键值的散列值为正整数k，则我们可以将**<code>k % M</code>**，那么我们得到的就是分布在0~M-1的某个值了。</p></blockquote><ul><li><code>hashCode()</code>返回的是一个32位比特整数，一般为内存地址经算法产生。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> ((key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是一个简单的散列函数，其中0x7fffffff是最大的正整数（无符号32位 0111 1111 1111 1111 1111 1111 1111 1111），通过&amp;0x7fffffff，可以得到一个<strong>去符号的31位整数</strong>，然后<strong>再与M取余</strong>即可得到键的hash索引。</p><ul><li>有时候hash索引会产生重复，处理好小整数M内的重复情况是关键。</li></ul><h3 id="软缓存"><a href="#软缓存" class="headerlink" title="软缓存"></a>软缓存</h3><p>对于有些散列函数，在处理过程中比较耗时，我们可以采用临时变量存储计算后的<code>hashCode()</code>，Java中的String就是如此处理的。</p><h3 id="散列表实现——链表"><a href="#散列表实现——链表" class="headerlink" title="散列表实现——链表"></a>散列表实现——链表</h3><p>链表实现即为每个键所转化的索引放入一个M大小的数组中，再将索引重复的键值以链表的方式存储在每个数组内。（数组嵌套链表）</p><p><img src="http://upload-images.jianshu.io/upload_images/8390810-b81e0a273f193d99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插入示意图"></p><p>假设我们这里有一个<strong>顺序存放数据的链表</strong>SequentialSearchST，拥有<code>get(key), put(key,value), delete(key)</code>几个常用的方法，具体代码参见<a href="https://github.com/759233960/Algorithms-4th-Exercise/blob/master/src/exercise/chapter3_1/SequentialSearchST.java">我的Github源码</a>。</p><h4 id="构造-constructor："><a href="#构造-constructor：" class="headerlink" title="构造 constructor："></a>构造 constructor：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateChainingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值总对数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;<span class="comment">//散列表大小</span></span><br><span class="line">    <span class="keyword">private</span> SequentialSearchST&lt;Key, Value&gt;[] st;<span class="comment">//存放链表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">997</span>);<span class="comment">//默认构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">(<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.M = M;</span><br><span class="line">        st = (SequentialSearchST&lt;Key, Value&gt;[]) <span class="keyword">new</span> SequentialSearchST[M];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">            st[i] = <span class="keyword">new</span> SequentialSearchST();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">return</span> ((key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找-get："><a href="#查找-get：" class="headerlink" title="查找 get："></a>查找 get：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> (Value) st[hash(key)].get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入-put："><a href="#插入-put：" class="headerlink" title="插入 put："></a>插入 put：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        delete(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//动态调整散列表的大小</span></span><br><span class="line">        <span class="keyword">if</span> (N &gt;= <span class="number">10</span> * M) resize(<span class="number">2</span> * M);</span><br><span class="line">        <span class="keyword">if</span> (!st[hash(key)].contains(key)) N++;</span><br><span class="line">        st[hash(key)].put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态调整散列表的大小，这里的调整临界值非固定，这里达到1/10就调整只是为了较为均衡的分布利用空间。</p><h4 id="动态调整-resize："><a href="#动态调整-resize：" class="headerlink" title="动态调整 resize："></a>动态调整 resize：</h4><p>动态调整散列表的大小不是必须的，但如同数组的动态变换大小一样，这样可以优化内存的空间利用，减少重复copy次数带来的开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> chains)</span> </span>&#123;</span><br><span class="line">    SeparateChainingHashST&lt;Key, Value&gt; temp = <span class="keyword">new</span> SeparateChainingHashST(chains);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        Iterator&lt;Key&gt; iterator = st[i].keys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Key key = iterator.next();</span><br><span class="line">            Value value = st[i].get(key);</span><br><span class="line">            temp.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    M = temp.M;</span><br><span class="line">    N = temp.N;</span><br><span class="line">    st = temp.st;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-delete："><a href="#删除-delete：" class="headerlink" title="删除 delete："></a>删除 delete：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">if</span> (get(key) == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">if</span> (st[hash(key)].contains(key))</span><br><span class="line">            N--;</span><br><span class="line">        st[hash(key)].delete(key);</span><br><span class="line">        <span class="keyword">if</span> (M &gt; <span class="number">4</span> &amp;&amp; N &lt;= <span class="number">2</span> * M) resize(M / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="散列表实现——数组"><a href="#散列表实现——数组" class="headerlink" title="散列表实现——数组"></a>散列表实现——数组</h3><p>实现散列表的另一种方式是通过数组来完成，用大小为M 的数组和N 的键值对（M &gt; N）来存储。其中当键值对重复时，我们需要使用数组中的空位来解决冲突。这种方法也被称为<strong>开放地址散列表</strong>。</p><p>当碰撞发生时（某键的散列值已被使用），则我们直接向下寻找位置：</p><ul><li>命中，键值相同。</li><li>未命中，键值为空（没有键），此时可执行插入。</li><li>继续向下，该键与当前键不同。</li></ul><blockquote><p><strong>开放地址散列表</strong>的核心思想是与其将内存用作链表（与链表实现对比），不如将他们作为散列表中的空元素，这些空元素可以作为查找结束的标志。</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/8390810-7dfe0d5c2f267970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插入实现过程"></p><p><strong>我们在维护键对应的值的时候，采用并行数组来解决，一条保存键，一条保存值。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;      <span class="comment">//total number of item</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;      <span class="comment">//Size of map , M &gt; N</span></span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> Value[] values;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">16</span>);<span class="comment">//default construct</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.M = cap;</span><br><span class="line">        <span class="keyword">this</span>.N = <span class="number">0</span>;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">        values = (Value[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">return</span> ((key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找-get：-1"><a href="#查找-get：-1" class="headerlink" title="查找 get："></a>查找 get：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i + <span class="number">1</span>) % M) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keys[i].equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> values[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是使用数组实现，所以查找比较简单，开销很小，最差情况也能在 O(logN) 内能完成。</p><h4 id="插入-put：-1"><a href="#插入-put：-1" class="headerlink" title="插入 put："></a>插入 put：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (N &gt;= M / <span class="number">2</span>) resize(<span class="number">2</span> * M);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) delete(key);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i + <span class="number">1</span>) % M) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keys[i].equals(key)) &#123;</span><br><span class="line">            values[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    keys[i] = key;</span><br><span class="line">    values[i] = value;</span><br><span class="line">    N++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入的时候，要注意散列表大小最好需要动态变化。这里为了保证使用的内存量和键值对数量的比例在某一范围内，采用1/2。</p><h4 id="删除-delete：-1"><a href="#删除-delete：-1" class="headerlink" title="删除 delete："></a>删除 delete：</h4><ol><li>先查找到键的位置</li><li>将键赋空删除</li><li>如果删除的键后面没有键（不连续），则删除操作结束。</li><li>如果删除的键后面连续还有键，则需要将后面的连续键向前移动一格位置。</li></ol><p>前三步不难理解，那么第四步这么做的原因，主要是因为如果不将后面的键向前移动位置使之保持连续，那么在之后的查找过程中会出现错误。<br>比如（见上图）我们查找H，此时C已被删除。若我们不向前移动H，那么查找操作将会返回不存在H，因为H实际存储在7的位置（散列值为4）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty() || !contains(key)) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">int</span> i = hash(key);</span><br><span class="line">    <span class="keyword">while</span> (!key.equals(keys[i])) &#123;</span><br><span class="line">        i = (i + <span class="number">1</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    keys[i] = <span class="keyword">null</span>;</span><br><span class="line">    values[i] = <span class="keyword">null</span>;</span><br><span class="line">    i = (i + <span class="number">1</span>) % M;</span><br><span class="line">    <span class="keyword">while</span> (keys[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Key keyToRedo = keys[i];</span><br><span class="line">        Value valueToRedo = values[i];</span><br><span class="line">        keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        values[i] = <span class="keyword">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        put(keyToRedo, valueToRedo);</span><br><span class="line">        i = (i + <span class="number">1</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    N--;</span><br><span class="line">    <span class="keyword">if</span> (N &gt; <span class="number">0</span> &amp;&amp; N &lt;= M / <span class="number">8</span>) resize(M / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="键簇："><a href="#键簇：" class="headerlink" title="键簇："></a>键簇：</h4><p>上面删除操作中提到连续的键值，这里引入一个概念——键簇来表示连续的键。数组实现的散列表操作平均开销是与键簇的分布直接相关的。</p><blockquote><p><strong>显然只有短小的键簇才能保证较高的效率。</strong></p></blockquote><p>因为当键簇长了后，每次查找（例如查找H）的遍历次数会越来越多，导致耗时增加。我们希望散列表中键簇的分布均匀且长度大部分合适。<br>对于不断的插入键，散列表会越填越满，直至连成大的键簇。这样性能会变的很差，为了保证性能，我们只能牺牲内存开销，动态的调整散列表的大小。</p><h4 id="调整数组大小-resize："><a href="#调整数组大小-resize：" class="headerlink" title="调整数组大小 resize："></a>调整数组大小 resize：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;<span class="comment">//must be needed</span></span><br><span class="line">    LinearProbingHashST&lt;Key, Value&gt; t;</span><br><span class="line">    t = <span class="keyword">new</span> LinearProbingHashST&lt;&gt;(cap);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        <span class="keyword">if</span> (keys[i] != <span class="keyword">null</span>)</span><br><span class="line">            t.put(keys[i], values[i]);</span><br><span class="line">    keys = t.keys;</span><br><span class="line">    values = t.values;</span><br><span class="line">    M = t.M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现比较简单，直接赋值一个新的大小的数组即可。</p><h3 id="性能："><a href="#性能：" class="headerlink" title="性能："></a>性能：</h3><p>对于各种常见的符号表而言，这里做一个性能汇总：</p><table><thead><tr><th align="left">算法</th><th align="center">最坏情况</th><th align="center">平均情况</th><th align="center">内存使用</th></tr></thead><tbody><tr><td align="left">顺序查找（无序链表）</td><td align="center">N</td><td align="center">N</td><td align="center">48N</td></tr><tr><td align="left">二分查找（有序数组）</td><td align="center">logN</td><td align="center">logN</td><td align="center">16N</td></tr><tr><td align="left">二叉树查找（二叉树）</td><td align="center">N</td><td align="center">1.39logN</td><td align="center">64N</td></tr><tr><td align="left">红黑树查找（红黑树）</td><td align="center">2logN</td><td align="center">logN</td><td align="center">64N</td></tr><tr><td align="left">散列表（数组）</td><td align="center">logN</td><td align="center">N/M</td><td align="center">48N+32M</td></tr><tr><td align="left">散列表（链表）</td><td align="center">logN</td><td align="center">1.5(get) 2.5(put)</td><td align="center">32N~128N</td></tr></tbody></table><p>根据经验而言，一般会<strong>优先选用散列表</strong>，实现简单并且性能优秀。除非是其他因素，才会选择红黑树来实现，因为红黑树在logN内支持的操作更多。</p><p><strong>谢谢观看。</strong></p><hr><p><em>参考文献：《算法导论》 《Algorithms, 4th Edition》</em></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter3_4/SeparateChainingHashST.java&quot;&gt;&lt;strong&gt;链表&lt;/strong&gt;实现 Github源码&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/yif-hong/Algorithms-4th-Exercise/blob/master/src/exercise/chapter3_4/LinearProbingHastST.java&quot;&gt;&lt;strong&gt;数组&lt;/strong&gt;实现 Github源码&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你需要一个&lt;strong&gt;简单&lt;/strong&gt;而不失优雅的&lt;strong&gt;无序&lt;/strong&gt;数据表，那么散列表一定是你的首选。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在我们&lt;strong&gt;分布较好&lt;/strong&gt;（近似均摊）的散列表内，查找、插入等操作一般在&lt;strong&gt;常数级别&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;em&gt;所有的数据结构都是在时间与空间上作出了平衡选择，而散列表则非常好的找到了平衡点。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://yif-hong.github.io/tags/Algorithm/"/>
    
      <category term="Java" scheme="http://yif-hong.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
